<!DOCTYPE html>
<html lang="ko"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Algebra · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-110655381-2', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="/js/jquery-1.8.3.min.js"></script><script src="/js/jquery.word-break-keep-all.min.js"></script><script>$(document).ready(function() { $('p').wordBreakKeepAll(); });</script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">소개글</a></li><li><a class="toctext" href="../manual/getting-started.html">시작하기</a></li><li><a class="toctext" href="../manual/variables.html">변수</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">정수와 부동소수점으로 표현되는 실수</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">함수</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/methods.html">메소드</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/arrays.html">다차원 배열</a></li><li><a class="toctext" href="../manual/linear-algebra.html">선형 대수</a></li><li><a class="toctext" href="../manual/missing.html">Missing Values</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="base.html">Essentials</a></li><li><a class="toctext" href="collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="math.html">Mathematics</a></li><li><a class="toctext" href="numbers.html">Numbers</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="parallel.html">Tasks and Parallel Computing</a></li><li class="current"><a class="toctext" href="linalg.html">Linear Algebra</a><ul class="internal"><li><a class="toctext" href="#Standard-Functions-1">Standard Functions</a></li><li><a class="toctext" href="#Low-level-matrix-operations-1">Low-level matrix operations</a></li><li><a class="toctext" href="#BLAS-Functions-1">BLAS Functions</a></li><li><a class="toctext" href="#LAPACK-Functions-1">LAPACK Functions</a></li></ul></li><li><a class="toctext" href="constants.html">Constants</a></li><li><a class="toctext" href="file.html">Filesystem</a></li><li><a class="toctext" href="delimitedfiles.html">Delimited Files</a></li><li><a class="toctext" href="io-network.html">I/O and Network</a></li><li><a class="toctext" href="punctuation.html">Punctuation</a></li><li><a class="toctext" href="sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="dates.html">Dates and Time</a></li><li><a class="toctext" href="iterators.html">Iteration utilities</a></li><li><a class="toctext" href="test.html">Unit Testing</a></li><li><a class="toctext" href="c.html">C Interface</a></li><li><a class="toctext" href="libc.html">C Standard Library</a></li><li><a class="toctext" href="libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">StackTraces</a></li><li><a class="toctext" href="simd-types.html">SIMD Support</a></li><li><a class="toctext" href="base64.html">Base64</a></li><li><a class="toctext" href="mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="sharedarrays.html">Shared Arrays</a></li><li><a class="toctext" href="filewatching.html">File Events</a></li><li><a class="toctext" href="crc32c.html">CRC32c</a></li><li><a class="toctext" href="iterativeeigensolvers.html">Iterative Eigensolvers</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href="linalg.html">Linear Algebra</a></li></ul><a class="edit-page" href="https://github.com/juliakorea/translate-doc/blob/master/src/stdlib/linalg.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Linear Algebra</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Linear-Algebra-1" href="#Linear-Algebra-1">Linear Algebra</a></h1><h2><a class="nav-anchor" id="Standard-Functions-1" href="#Standard-Functions-1">Standard Functions</a></h2><p>Linear algebra functions in Julia are largely implemented by calling functions from <a href="http://www.netlib.org/lapack/">LAPACK</a>.  Sparse factorizations call functions from <a href="http://faculty.cse.tamu.edu/davis/suitesparse.html">SuiteSparse</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}" href="#Base.:*-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">*(A::AbstractMatrix, B::AbstractMatrix)</code></pre><p>Matrix multiplication.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; [1 1; 0 1] * [1 0; 1 1]
2×2 Array{Int64,2}:
 2  1
 1  1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/matmul.jl#L128-L142">source</a><div><pre><code class="language-none">*(x, y...)</code></pre><p>Multiplication operator. <code>x*y*z*...</code> calls this function with all arguments, i.e. <code>*(x, y, z, ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 2 * 7 * 8
112

julia&gt; *(2, 7, 8)
112</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/docs/basedocs.jl#L1448-L1461">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">\(A, B)</code></pre><p>Matrix division using a polyalgorithm. For input matrices <code>A</code> and <code>B</code>, the result <code>X</code> is such that <code>A*X == B</code> when <code>A</code> is square. The solver that is used depends upon the structure of <code>A</code>.  If <code>A</code> is upper or lower triangular (or diagonal), no factorization of <code>A</code> is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</p><p>For rectangular <code>A</code> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <code>A</code> and a rank estimate of <code>A</code> based on the R factor.</p><p>When <code>A</code> is sparse, a similar polyalgorithm is used. For indefinite matrices, the <code>LDLt</code> factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 1 -2]; B = [32; -4];

julia&gt; X = A \ B
2-element Array{Float64,1}:
 32.0
 18.0

julia&gt; A * X == B
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L835-L863">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.dot" href="#Base.LinAlg.dot"><code>Base.LinAlg.dot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dot(x, y)
⋅(x,y)</code></pre><p>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated. When the vectors have equal lengths, calling <code>dot</code> is semantically equivalent to <code>sum(vx&#39;vy for (vx,vy) in zip(x, y))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dot([1; 1], [2; 3])
5

julia&gt; dot([im; im], [1; 1])
0 - 2im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L686-L701">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.vecdot" href="#Base.LinAlg.vecdot"><code>Base.LinAlg.vecdot</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vecdot(x, y)</code></pre><p>For any iterable containers <code>x</code> and <code>y</code> (including arrays of any dimension) of numbers (or any element type for which <code>dot</code> is defined), compute the Euclidean dot product (the sum of <code>dot(x[i],y[i])</code>) as if they were vectors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vecdot(1:5, 2:6)
70

julia&gt; x = fill(2., (5,5));

julia&gt; y = fill(3., (5,5));

julia&gt; vecdot(x, y)
150.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L633-L652">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cross" href="#Base.LinAlg.cross"><code>Base.LinAlg.cross</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cross(x, y)
×(x,y)</code></pre><p>Compute the cross product of two 3-vectors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia&gt; b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia&gt; cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L87-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.factorize" href="#Base.LinAlg.factorize"><code>Base.LinAlg.factorize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">factorize(A)</code></pre><p>Compute a convenient factorization of <code>A</code>, based upon the type of the input matrix. <code>factorize</code> checks <code>A</code> to see if it is symmetric/triangular/etc. if <code>A</code> is passed as a generic matrix. <code>factorize</code> checks every element of <code>A</code> to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: <code>A=factorize(A); x=A\b; y=A\C</code>.</p><table><tr><th>Properties of <code>A</code></th><th>type of factorization</th></tr><tr><td>Positive-definite</td><td>Cholesky (see <a href="linalg.html#Base.LinAlg.cholfact"><code>cholfact</code></a>)</td></tr><tr><td>Dense Symmetric/Hermitian</td><td>Bunch-Kaufman (see <a href="linalg.html#Base.LinAlg.bkfact"><code>bkfact</code></a>)</td></tr><tr><td>Sparse Symmetric/Hermitian</td><td>LDLt (see <a href="linalg.html#Base.LinAlg.ldltfact"><code>ldltfact</code></a>)</td></tr><tr><td>Triangular</td><td>Triangular</td></tr><tr><td>Diagonal</td><td>Diagonal</td></tr><tr><td>Bidiagonal</td><td>Bidiagonal</td></tr><tr><td>Tridiagonal</td><td>LU (see <a href="linalg.html#Base.LinAlg.lufact"><code>lufact</code></a>)</td></tr><tr><td>Symmetric real tridiagonal</td><td>LDLt (see <a href="linalg.html#Base.LinAlg.ldltfact"><code>ldltfact</code></a>)</td></tr><tr><td>General square</td><td>LU (see <a href="linalg.html#Base.LinAlg.lufact"><code>lufact</code></a>)</td></tr><tr><td>General non-square</td><td>QR (see <a href="linalg.html#Base.LinAlg.qrfact"><code>qrfact</code></a>)</td></tr></table><p>If <code>factorize</code> is called on a Hermitian positive-definite matrix, for instance, then <code>factorize</code> will return a Cholesky factorization.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Array(Bidiagonal(ones(5, 5), :U))
5×5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia&gt; factorize(A) # factorize will check to see that A is already factorized
5×5 Bidiagonal{Float64,Array{Float64,1}}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0</code></pre><p>This returns a <code>5×5 Bidiagonal{Float64}</code>, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for <code>Bidiagonal</code> types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1103-L1149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Diagonal" href="#Base.LinAlg.Diagonal"><code>Base.LinAlg.Diagonal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Diagonal(A::AbstractMatrix)</code></pre><p>Construct a matrix from the diagonal of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; Diagonal(A)
3×3 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅
 ⋅  5  ⋅
 ⋅  ⋅  9</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/diagonal.jl#L8-L27">source</a><div><pre><code class="language-none">Diagonal(V::AbstractVector)</code></pre><p>Construct a matrix with <code>V</code> as its diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; V = [1, 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; Diagonal(V)
2×2 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅
 ⋅  2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/diagonal.jl#L30-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Bidiagonal" href="#Base.LinAlg.Bidiagonal"><code>Base.LinAlg.Bidiagonal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Bidiagonal(dv::V, ev::V, uplo::Symbol) where V &lt;: AbstractVector</code></pre><p>Constructs an upper (<code>uplo=:U</code>) or lower (<code>uplo=:L</code>) bidiagonal matrix using the given diagonal (<code>dv</code>) and off-diagonal (<code>ev</code>) vectors. The result is of type <code>Bidiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="base.html#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The length of <code>ev</code> must be one less than the length of <code>dv</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia&gt; Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/bidiag.jl#L19-L57">source</a><div><pre><code class="language-none">Bidiagonal(A, uplo::Symbol)</code></pre><p>Construct a <code>Bidiagonal</code> matrix from the main diagonal of <code>A</code> and its first super- (if <code>uplo=:U</code>) or sub-diagonal (if <code>uplo=:L</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia&gt; Bidiagonal(A, :U) # contains the main diagonal and first superdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia&gt; Bidiagonal(A, :L) # contains the main diagonal and first subdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/bidiag.jl#L62-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.SymTridiagonal" href="#Base.LinAlg.SymTridiagonal"><code>Base.LinAlg.SymTridiagonal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SymTridiagonal(dv::V, ev::V) where V &lt;: AbstractVector</code></pre><p>Construct a symmetric tridiagonal matrix from the diagonal (<code>dv</code>) and first sub/super-diagonal (<code>ev</code>), respectively. The result is of type <code>SymTridiagonal</code> and provides efficient specialized eigensolvers, but may be converted into a regular matrix with <a href="base.html#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/tridiag.jl#L17-L47">source</a><div><pre><code class="language-none">SymTridiagonal(A::AbstractMatrix)</code></pre><p>Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 2 4 5; 3 5 6]
3×3 Array{Int64,2}:
 1  2  3
 2  4  5
 3  5  6

julia&gt; SymTridiagonal(A)
3×3 SymTridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅
 2  4  5
 ⋅  5  6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/tridiag.jl#L50-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Tridiagonal" href="#Base.LinAlg.Tridiagonal"><code>Base.LinAlg.Tridiagonal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Tridiagonal(dl::V, d::V, du::V) where V &lt;: AbstractVector</code></pre><p>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type <code>Tridiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="base.html#Base.convert"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The lengths of <code>dl</code> and <code>du</code> must be one less than the length of <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dl = [1, 2, 3];

julia&gt; du = [4, 5, 6];

julia&gt; d = [7, 8, 9, 0];

julia&gt; Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/tridiag.jl#L416-L440">source</a><div><pre><code class="language-none">Tridiagonal(A)</code></pre><p>Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia&gt; Tridiagonal(A)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/tridiag.jl#L443-L465">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Symmetric" href="#Base.LinAlg.Symmetric"><code>Base.LinAlg.Symmetric</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Symmetric(A, uplo=:U)</code></pre><p>Construct a <code>Symmetric</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5×5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia&gt; Supper = Symmetric(A)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia&gt; Slower = Symmetric(A, :L)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4</code></pre><p>Note that <code>Supper</code> will not be equal to <code>Slower</code> unless <code>A</code> is itself symmetric (e.g. if <code>A == A.&#39;</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/symmetric.jl#L8-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Hermitian" href="#Base.LinAlg.Hermitian"><code>Base.LinAlg.Hermitian</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Hermitian(A, uplo=:U)</code></pre><p>Construct a <code>Hermitian</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia&gt; Hupper = Hermitian(A)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia&gt; Hlower = Hermitian(A, :L)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im</code></pre><p>Note that <code>Hupper</code> will not be equal to <code>Hlower</code> unless <code>A</code> is itself Hermitian (e.g. if <code>A == A&#39;</code>).</p><p>All non-real parts of the diagonal will be ignored.</p><pre><code class="language-julia">Hermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/symmetric.jl#L49-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LowerTriangular" href="#Base.LinAlg.LowerTriangular"><code>Base.LinAlg.LowerTriangular</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LowerTriangular(A::AbstractMatrix)</code></pre><p>Construct a <code>LowerTriangular</code> view of the the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; LowerTriangular(A)
3×3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/triangular.jl#L55-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.UpperTriangular" href="#Base.LinAlg.UpperTriangular"><code>Base.LinAlg.UpperTriangular</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">UpperTriangular(A::AbstractMatrix)</code></pre><p>Construct an <code>UpperTriangular</code> view of the the matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UpperTriangular(A)
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/triangular.jl#L76-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.UniformScaling" href="#Base.LinAlg.UniformScaling"><code>Base.LinAlg.UniformScaling</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">UniformScaling{T&lt;:Number}</code></pre><p>Generically sized uniform scaling operator defined as a scalar times the identity operator, <code>λ*I</code>. See also <a href="linalg.html#Base.LinAlg.I"><code>I</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; J = UniformScaling(2.)
UniformScaling{Float64}
2.0*I

julia&gt; A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; J*A
2×2 Array{Float64,2}:
 2.0  4.0
 6.0  8.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/uniformscaling.jl#L7-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lu" href="#Base.LinAlg.lu"><code>Base.LinAlg.lu</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lu(A, pivot=Val(true)) -&gt; L, U, p</code></pre><p>Compute the LU factorization of <code>A</code>, such that <code>A[p,:] = L*U</code>. By default, pivoting is used. This can be overridden by passing <code>Val(false)</code> for the second argument.</p><p>See also <a href="linalg.html#Base.LinAlg.lufact"><code>lufact</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia&gt; L, U, p = lu(A)
([1.0 0.0; 0.666667 1.0], [6.0 3.0; 0.0 1.0], [2, 1])

julia&gt; A[p, :] == L * U
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lu.jl#L202-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lufact" href="#Base.LinAlg.lufact"><code>Base.LinAlg.lufact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lufact(A, pivot=Val(true)) -&gt; F::LU</code></pre><p>Compute the LU factorization of <code>A</code>.</p><p>In most cases, if <code>A</code> is a subtype <code>S</code> of <code>AbstractMatrix{T}</code> with an element type <code>T</code> supporting <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>, the return type is <code>LU{T,S{T}}</code>. If pivoting is chosen (default) the element type should also support <code>abs</code> and <code>&lt;</code>.</p><p>The individual components of the factorization <code>F</code> can be accessed by indexing:</p><table><tr><th>Component</th><th>Description</th></tr><tr><td><code>F[:L]</code></td><td><code>L</code> (lower triangular) part of <code>LU</code></td></tr><tr><td><code>F[:U]</code></td><td><code>U</code> (upper triangular) part of <code>LU</code></td></tr><tr><td><code>F[:p]</code></td><td>(right) permutation <code>Vector</code></td></tr><tr><td><code>F[:P]</code></td><td>(right) permutation <code>Matrix</code></td></tr></table><p>The relationship between <code>F</code> and <code>A</code> is</p><p><code>F[:L]*F[:U] == A[F[:p], :]</code></p><p><code>F</code> further supports the following functions:</p><table><tr><th>Supported function</th><th><code>LU</code></th><th><code>LU{T,Tridiagonal{T}}</code></th></tr><tr><td><a href="math.html#Base.:/"><code>/</code></a></td><td>✓</td><td></td></tr><tr><td><a href="linalg.html#Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>\</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="linalg.html#Base.LinAlg.det"><code>det</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="linalg.html#Base.LinAlg.logdet"><code>logdet</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="linalg.html#Base.LinAlg.logabsdet"><code>logabsdet</code></a></td><td>✓</td><td>✓</td></tr><tr><td><a href="arrays.html#Base.size"><code>size</code></a></td><td>✓</td><td>✓</td></tr></table><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia&gt; F = lufact(A)
Base.LinAlg.LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0  0.0
 1.5  1.0
U factor:
2×2 Array{Float64,2}:
 4.0   3.0
 0.0  -1.5

julia&gt; F[:L] * F[:U] == A[F[:p], :]
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lu.jl#L119-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lufact!" href="#Base.LinAlg.lufact!"><code>Base.LinAlg.lufact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lufact!(A, pivot=Val(true)) -&gt; LU</code></pre><p><code>lufact!</code> is the same as <a href="linalg.html#Base.LinAlg.lufact"><code>lufact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="base.html#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 6.0  3.0
 4.0  3.0

julia&gt; F = lufact!(A)
Base.LinAlg.LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia&gt; iA = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia&gt; lufact!(iA)
ERROR: InexactError: convert(Int64, 0.6666666666666666)
Stacktrace:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lu.jl#L27-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.chol" href="#Base.LinAlg.chol"><code>Base.LinAlg.chol</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">chol(A) -&gt; U</code></pre><p>Compute the Cholesky factorization of a positive definite matrix <code>A</code> and return the <a href="linalg.html#Base.LinAlg.UpperTriangular"><code>UpperTriangular</code></a> matrix <code>U</code> such that <code>A = U&#39;U</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 2.; 2. 50.]
2×2 Array{Float64,2}:
 1.0   2.0
 2.0  50.0

julia&gt; U = chol(A)
2×2 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0
  ⋅   6.78233

julia&gt; U&#39;U
2×2 Array{Float64,2}:
 1.0   2.0
 2.0  50.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L162-L185">source</a><div><pre><code class="language-none">chol(x::Number) -&gt; y</code></pre><p>Compute the square root of a non-negative number <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; chol(16)
4.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L189-L199">source</a><div><pre><code class="language-none">chol(J::UniformScaling) -&gt; C</code></pre><p>Compute the square root of a non-negative UniformScaling <code>J</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; chol(16I)
UniformScaling{Float64}
4.0*I</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/uniformscaling.jl#L361-L372">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cholfact" href="#Base.LinAlg.cholfact"><code>Base.LinAlg.cholfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cholfact(A, Val(false)) -&gt; Cholesky</code></pre><p>Compute the Cholesky factorization of a dense symmetric positive definite matrix <code>A</code> and return a <code>Cholesky</code> factorization. The matrix <code>A</code> can either be a <a href="linalg.html#Base.LinAlg.Symmetric"><code>Symmetric</code></a> or <a href="linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F[:L]</code> and <code>F[:U]</code>. The following functions are available for <code>Cholesky</code> objects: <a href="arrays.html#Base.size"><code>size</code></a>, <a href="linalg.html#Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>\</code></a>, <a href="linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="linalg.html#Base.LinAlg.det"><code>det</code></a>, <a href="linalg.html#Base.LinAlg.logdet"><code>logdet</code></a> and <a href="linalg.html#Base.LinAlg.isposdef"><code>isposdef</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholfact(A)
Base.LinAlg.Cholesky{Float64,Array{Float64,2}}
U factor:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C[:U]
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C[:L]
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C[:L] * C[:U] == A
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L282-L323">source</a><div><pre><code class="language-none">cholfact(A, Val(true); tol = 0.0) -&gt; CholeskyPivoted</code></pre><p>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix <code>A</code> and return a <code>CholeskyPivoted</code> factorization. The matrix <code>A</code> can either be a <a href="linalg.html#Base.LinAlg.Symmetric"><code>Symmetric</code></a> or <a href="linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F[:L]</code> and <code>F[:U]</code>. The following functions are available for <code>PivotedCholesky</code> objects: <a href="arrays.html#Base.size"><code>size</code></a>, <a href="linalg.html#Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>\</code></a>, <a href="linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="linalg.html#Base.LinAlg.det"><code>det</code></a>, and <a href="linalg.html#Base.LinAlg.rank"><code>rank</code></a>. The argument <code>tol</code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L329-L340">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cholfact!" href="#Base.LinAlg.cholfact!"><code>Base.LinAlg.cholfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cholfact!(A, Val(false)) -&gt; Cholesky</code></pre><p>The same as <a href="linalg.html#Base.LinAlg.cholfact"><code>cholfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="base.html#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia&gt; cholfact!(A)
ERROR: InexactError: convert(Int64, 6.782329983125268)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L218-L236">source</a><div><pre><code class="language-none">cholfact!(A, Val(true); tol = 0.0) -&gt; CholeskyPivoted</code></pre><p>The same as <a href="linalg.html#Base.LinAlg.cholfact"><code>cholfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="base.html#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L261-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lowrankupdate" href="#Base.LinAlg.lowrankupdate"><code>Base.LinAlg.lowrankupdate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowrankupdate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C[:U]&#39;C[:U]</code> then <code>CC = cholfact(C[:U]&#39;C[:U] + v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L633-L639">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lowrankdowndate" href="#Base.LinAlg.lowrankdowndate"><code>Base.LinAlg.lowrankdowndate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowrankdowndate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C[:U]&#39;C[:U]</code> then <code>CC = cholfact(C[:U]&#39;C[:U] - v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L642-L648">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lowrankupdate!" href="#Base.LinAlg.lowrankupdate!"><code>Base.LinAlg.lowrankupdate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowrankupdate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C[:U]&#39;C[:U]</code> then <code>CC = cholfact(C[:U]&#39;C[:U] + v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L534-L541">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lowrankdowndate!" href="#Base.LinAlg.lowrankdowndate!"><code>Base.LinAlg.lowrankdowndate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowrankdowndate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky</code></pre><p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C[:U]&#39;C[:U]</code> then <code>CC = cholfact(C[:U]&#39;C[:U] - v*v&#39;)</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/cholesky.jl#L580-L587">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ldltfact" href="#Base.LinAlg.ldltfact"><code>Base.LinAlg.ldltfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ldltfact(S::SymTridiagonal) -&gt; LDLt</code></pre><p>Compute an <code>LDLt</code> factorization of the real symmetric tridiagonal matrix <code>S</code> such that <code>S = L*Diagonal(d)*L&#39;</code> where <code>L</code> is a unit lower triangular matrix and <code>d</code> is a vector. The main use of an <code>LDLt</code> factorization <code>F = ldltfact(S)</code> is to solve the linear system of equations <code>Sx = b</code> with <code>F\b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldltfact(S);

julia&gt; b = [6., 7., 8.];

julia&gt; ldltS \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255

julia&gt; S \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/ldlt.jl#L55-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ldltfact!" href="#Base.LinAlg.ldltfact!"><code>Base.LinAlg.ldltfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ldltfact!(S::SymTridiagonal) -&gt; LDLt</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.ldltfact"><code>ldltfact</code></a>, but saves space by overwriting the input <code>S</code>, instead of creating a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldltfact!(S);

julia&gt; ldltS === S
false

julia&gt; S
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0       0.333333   ⋅
 0.333333  3.66667   0.545455
  ⋅        0.545455  3.90909</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/ldlt.jl#L19-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.qr" href="#Base.LinAlg.qr"><code>Base.LinAlg.qr</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">qr(A, pivot=Val(false); full::Bool = false) -&gt; Q, R, [p]</code></pre><p>Compute the (pivoted) QR factorization of <code>A</code> such that either <code>A = Q*R</code> or <code>A[:,p] = Q*R</code>. Also see <a href="linalg.html#Base.LinAlg.qrfact"><code>qrfact</code></a>. The default is to compute a &quot;thin&quot; factorization. Note that <code>R</code> is not extended with zeros when a full/square orthogonal factor <code>Q</code> is requested (via <code>full = true</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/qr.jl#L309-L316">source</a><div><pre><code class="language-none">qr(v::AbstractVector) -&gt; w, r</code></pre><p>Computes the polar decomposition of a vector. Returns <code>w</code>, a unit vector in the direction of <code>v</code>, and <code>r</code>, the norm of <code>v</code>.</p><p>See also <a href="linalg.html#Base.LinAlg.normalize"><code>normalize</code></a>, <a href="linalg.html#Base.LinAlg.normalize!"><code>normalize!</code></a>, and <a href="linalg.html#Base.LinAlg.qr!"><code>LinAlg.qr!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; w, r = qr(v)
([0.447214, 0.894427], 2.23606797749979)

julia&gt; w*r == v
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/qr.jl#L341-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.qr!" href="#Base.LinAlg.qr!"><code>Base.LinAlg.qr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">LinAlg.qr!(v::AbstractVector) -&gt; w, r</code></pre><p>Computes the polar decomposition of a vector. Instead of returning a new vector as <code>qr(v::AbstractVector)</code>, this function mutates the input vector <code>v</code> in place. Returns <code>w</code>, a unit vector in the direction of <code>v</code> (this is a mutation of <code>v</code>), and <code>r</code>, the norm of <code>v</code>.</p><p>See also <a href="linalg.html#Base.LinAlg.normalize"><code>normalize</code></a>, <a href="linalg.html#Base.LinAlg.normalize!"><code>normalize!</code></a>, and <a href="linalg.html#Base.LinAlg.qr"><code>qr</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1.; 2.]
2-element Array{Float64,1}:
 1.0
 2.0

julia&gt; w, r = Base.LinAlg.qr!(v)
([0.447214, 0.894427], 2.23606797749979)

julia&gt; w === v
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/qr.jl#L376-L400">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.qrfact" href="#Base.LinAlg.qrfact"><code>Base.LinAlg.qrfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">qrfact(A, pivot=Val(false)) -&gt; F</code></pre><p>Compute the QR factorization of the matrix <code>A</code>: an orthogonal (or unitary if <code>A</code> is complex-valued) matrix <code>Q</code>, and an upper triangular matrix <code>R</code> such that</p><div>\[A = Q R\]</div><p>The returned object <code>F</code> stores the factorization in a packed format:</p><ul><li><p>if <code>pivot == Val(true)</code> then <code>F</code> is a <a href="linalg.html#Base.LinAlg.QRPivoted"><code>QRPivoted</code></a> object,</p></li><li><p>otherwise if the element type of <code>A</code> is a BLAS type (<a href="numbers.html#Core.Float32"><code>Float32</code></a>, <a href="numbers.html#Core.Float64"><code>Float64</code></a>, <code>Complex64</code> or <code>Complex128</code>), then <code>F</code> is a <a href="linalg.html#Base.LinAlg.QRCompactWY"><code>QRCompactWY</code></a> object,</p></li><li><p>otherwise <code>F</code> is a <a href="linalg.html#Base.LinAlg.QR"><code>QR</code></a> object.</p></li></ul><p>The individual components of the factorization <code>F</code> can be accessed by indexing with a symbol:</p><ul><li><p><code>F[:Q]</code>: the orthogonal/unitary matrix <code>Q</code></p></li><li><p><code>F[:R]</code>: the upper triangular matrix <code>R</code></p></li><li><p><code>F[:p]</code>: the permutation vector of the pivot (<a href="linalg.html#Base.LinAlg.QRPivoted"><code>QRPivoted</code></a> only)</p></li><li><p><code>F[:P]</code>: the permutation matrix of the pivot (<a href="linalg.html#Base.LinAlg.QRPivoted"><code>QRPivoted</code></a> only)</p></li></ul><p>The following functions are available for the <code>QR</code> objects: <a href="linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="arrays.html#Base.size"><code>size</code></a>, and <a href="linalg.html#Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>\</code></a>. When <code>A</code> is rectangular, <code>\</code> will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.</p><p>Multiplication with respect to either full/square or non-full/square <code>Q</code> is allowed, i.e. both <code>F[:Q]*F[:R]</code> and <code>F[:Q]*A</code> are supported. A <code>Q</code> matrix can be converted into a regular matrix with <a href="arrays.html#Base.Matrix"><code>Matrix</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia&gt; F = qrfact(A)
Base.LinAlg.QRCompactWY{Float64,Array{Float64,2}} with factors Q and R:
[-0.6 0.0 0.8; -0.8 0.0 -0.6; 0.0 -1.0 0.0]
[-5.0 10.0; 0.0 -1.0]

julia&gt; F[:Q] * F[:R] == A
true</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>qrfact</code> returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the <code>Q</code> and <code>R</code> matrices can be stored compactly rather as two separate dense matrices.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/qr.jl#L240-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.qrfact!" href="#Base.LinAlg.qrfact!"><code>Base.LinAlg.qrfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">qrfact!(A, pivot=Val(false))</code></pre><p><code>qrfact!</code> is the same as <a href="linalg.html#Base.LinAlg.qrfact"><code>qrfact</code></a> when <code>A</code> is a subtype of <code>StridedMatrix</code>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="base.html#Core.InexactError"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; qrfact!(a)
Base.LinAlg.QRCompactWY{Float64,Array{Float64,2}} with factors Q and R:
[-0.316228 -0.948683; -0.948683 0.316228]
[-3.16228 -4.42719; 0.0 -0.632456]

julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; qrfact!(a)
ERROR: InexactError: convert(Int64, -3.1622776601683795)
Stacktrace:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/qr.jl#L203-L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.QR" href="#Base.LinAlg.QR"><code>Base.LinAlg.QR</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QR &lt;: Factorization</code></pre><p>A QR matrix factorization stored in a packed format, typically obtained from <a href="linalg.html#Base.LinAlg.qrfact"><code>qrfact</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p><div>\[A = Q R\]</div><p>where <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. The matrix <span>$Q$</span> is stored as a sequence of Householder reflectors <span>$v_i$</span> and coefficients <span>$\tau_i$</span> where:</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]</div><p>The object has two fields:</p><ul><li><p><code>factors</code> is an <code>m</code>×<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format where <span>$v_i$</span> is the <span>$i$</span>th column of the matrix <code>V = I + tril(F.factors, -1)</code>.</p></li></ul></li><li><p><code>τ</code> is a vector  of length <code>min(m,n)</code> containing the coefficients <span>$au_i$</span>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/qr.jl#L4-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.QRCompactWY" href="#Base.LinAlg.QRCompactWY"><code>Base.LinAlg.QRCompactWY</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QRCompactWY &lt;: Factorization</code></pre><p>A QR matrix factorization stored in a compact blocked format, typically obtained from <a href="linalg.html#Base.LinAlg.qrfact"><code>qrfact</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p><div>\[A = Q R\]</div><p>where <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. It is similar to the <a href="linalg.html#Base.LinAlg.QR"><code>QR</code></a> format except that the orthogonal/unitary matrix <span>$Q$</span> is stored in <em>Compact WY</em> format <a href="#footnote-Schreiber1989">[Schreiber1989]</a>, as a lower trapezoidal matrix <span>$V$</span> and an upper triangular matrix <span>$T$</span> where</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T) = I - V T V^T\]</div><p>such that <span>$v_i$</span> is the <span>$i$</span>th column of <span>$V$</span>, and <span>$au_i$</span> is the <span>$i$</span>th diagonal element of <span>$T$</span>.</p><p>The object has two fields:</p><ul><li><p><code>factors</code>, as in the <a href="linalg.html#Base.LinAlg.QR"><code>QR</code></a> type, is an <code>m</code>×<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format such that <code>V = I + tril(F.factors, -1)</code>.</p></li></ul></li><li><p><code>T</code> is a square matrix with <code>min(m,n)</code> columns, whose upper triangular part gives the matrix <span>$T$</span> above (the subdiagonal elements are ignored).</p></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This format should not to be confused with the older <em>WY</em> representation <a href="#footnote-Bischof1987">[Bischof1987]</a>.</p></div></div><div class="footnote" id="footnote-Bischof1987"><a href="#footnote-Bischof1987"><strong>[Bischof1987]</strong></a><p>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. <a href="http://dx.doi.org/10.1137/0908009">doi:10.1137/0908009</a></p></div><div class="footnote" id="footnote-Schreiber1989"><a href="#footnote-Schreiber1989"><strong>[Schreiber1989]</strong></a><p>R Schreiber and C Van Loan, &quot;A storage-efficient WY representation for products of Householder transformations&quot;, SIAM J Sci Stat Comput 10 (1989), 53-57. <a href="http://dx.doi.org/10.1137/0910005">doi:10.1137/0910005</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/qr.jl#L43-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.QRPivoted" href="#Base.LinAlg.QRPivoted"><code>Base.LinAlg.QRPivoted</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QRPivoted &lt;: Factorization</code></pre><p>A QR matrix factorization with column pivoting in a packed format, typically obtained from <a href="linalg.html#Base.LinAlg.qrfact"><code>qrfact</code></a>. If <span>$A$</span> is an <code>m</code>×<code>n</code> matrix, then</p><div>\[A P = Q R\]</div><p>where <span>$P$</span> is a permutation matrix, <span>$Q$</span> is an orthogonal/unitary matrix and <span>$R$</span> is upper triangular. The matrix <span>$Q$</span> is stored as a sequence of Householder reflectors:</p><div>\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]</div><p>The object has three fields:</p><ul><li><p><code>factors</code> is an <code>m</code>×<code>n</code> matrix.</p><ul><li><p>The upper triangular part contains the elements of <span>$R$</span>, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</p></li><li><p>The subdiagonal part contains the reflectors <span>$v_i$</span> stored in a packed format where <span>$v_i$</span> is the <span>$i$</span>th column of the matrix <code>V = I + tril(F.factors, -1)</code>.</p></li></ul></li><li><p><code>τ</code> is a vector of length <code>min(m,n)</code> containing the coefficients <span>$au_i$</span>.</p></li><li><p><code>jpvt</code> is an integer vector of length <code>n</code> corresponding to the permutation <span>$P$</span>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/qr.jl#L95-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lqfact!" href="#Base.LinAlg.lqfact!"><code>Base.LinAlg.lqfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lqfact!(A) -&gt; LQ</code></pre><p>Compute the LQ factorization of <code>A</code>, using the input matrix as a workspace. See also <a href="linalg.html#Base.LinAlg.lq"><code>lq</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lq.jl#L20-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lqfact" href="#Base.LinAlg.lqfact"><code>Base.LinAlg.lqfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lqfact(A) -&gt; LQ</code></pre><p>Compute the LQ factorization of <code>A</code>. See also <a href="linalg.html#Base.LinAlg.lq"><code>lq</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lq.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lq" href="#Base.LinAlg.lq"><code>Base.LinAlg.lq</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lq(A; full = false) -&gt; L, Q</code></pre><p>Perform an LQ factorization of <code>A</code> such that <code>A = L*Q</code>. The default (<code>full = false</code>) computes a factorization with possibly-rectangular <code>L</code> and <code>Q</code>, commonly the &quot;thin&quot; factorization. The LQ factorization is the QR factorization of <code>A.&#39;</code>. If the explicit, full/square form of <code>Q</code> is requested via <code>full = true</code>, <code>L</code> is not extended with zeros.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>While in QR factorization the &quot;thin&quot; factorization is so named due to yielding either a square or &quot;tall&quot;/&quot;thin&quot; rectangular factor <code>Q</code>, in LQ factorization the &quot;thin&quot; factorization somewhat confusingly produces either a square or &quot;short&quot;/&quot;wide&quot; rectangular factor <code>Q</code>. &quot;Thin&quot; factorizations more broadly are also referred to as &quot;reduced&quot; factorizatons.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lq.jl#L35-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.bkfact" href="#Base.LinAlg.bkfact"><code>Base.LinAlg.bkfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bkfact(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -&gt; BunchKaufman</code></pre><p>Compute the Bunch-Kaufman <a href="#footnote-Bunch1977">[Bunch1977]</a> factorization of a symmetric or Hermitian matrix <code>A</code> and return a <code>BunchKaufman</code> object. <code>uplo</code> indicates which triangle of matrix <code>A</code> to reference. If <code>symmetric</code> is <code>true</code>, <code>A</code> is assumed to be symmetric. If <code>symmetric</code> is <code>false</code>, <code>A</code> is assumed to be Hermitian. If <code>rook</code> is <code>true</code>, rook pivoting is used. If <code>rook</code> is false, rook pivoting is not used. The following functions are available for <code>BunchKaufman</code> objects: <a href="arrays.html#Base.size"><code>size</code></a>, <code>\</code>, <a href="linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="linalg.html#Base.LinAlg.issymmetric"><code>issymmetric</code></a>, <a href="linalg.html#Base.LinAlg.ishermitian"><code>ishermitian</code></a>.</p><div class="footnote" id="footnote-Bunch1977"><a href="#footnote-Bunch1977"><strong>[Bunch1977]</strong></a><p>J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. <a href="http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/">url</a>.</p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 3]
2×2 Array{Int64,2}:
 1  2
 2  3

julia&gt; bkfact(A)
Base.LinAlg.BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2×2 Base.LinAlg.UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
 0.0  1.0
permutation:
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/bunchkaufman.jl#L43-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.bkfact!" href="#Base.LinAlg.bkfact!"><code>Base.LinAlg.bkfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bkfact!(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -&gt; BunchKaufman</code></pre><p><code>bkfact!</code> is the same as <a href="linalg.html#Base.LinAlg.bkfact"><code>bkfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/bunchkaufman.jl#L19-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eig" href="#Base.LinAlg.eig"><code>Base.LinAlg.eig</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; D, V
eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; D, V
eig(A, permute::Bool=true, scale::Bool=true) -&gt; D, V</code></pre><p>Computes eigenvalues (<code>D</code>) and eigenvectors (<code>V</code>) of <code>A</code>. See <a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a> for details on the <code>irange</code>, <code>vl</code>, and <code>vu</code> arguments (for <a href="linalg.html#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a>, <a href="linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a>, and <a href="linalg.html#Base.LinAlg.Symmetric"><code>Symmetric</code></a> matrices) and the <code>permute</code> and <code>scale</code> keyword arguments. The eigenvectors are returned columnwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eig([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])</code></pre><p><code>eig</code> is a wrapper around <a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>, extracting all parts of the factorization to a tuple; where possible, using <a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a> is recommended.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L112-L133">source</a><div><pre><code class="language-none">eig(A, B) -&gt; D, V</code></pre><p>Computes generalized eigenvalues (<code>D</code>) and vectors (<code>V</code>) of <code>A</code> with respect to <code>B</code>.</p><p><code>eig</code> is a wrapper around <a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>, extracting all parts of the factorization to a tuple; where possible, using <a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a> is recommended.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eig(A, B)
(Complex{Float64}[0.0+1.0im, 0.0-1.0im], Complex{Float64}[0.0-1.0im 0.0+1.0im; -1.0-0.0im -1.0+0.0im])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L390-L413">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigvals" href="#Base.LinAlg.eigvals"><code>Base.LinAlg.eigvals</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigvals(A; permute::Bool=true, scale::Bool=true) -&gt; values</code></pre><p>Return the eigenvalues of <code>A</code>.</p><p>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; diag_matrix = [1 0; 0 4]
2×2 Array{Int64,2}:
 1  0
 0  4

julia&gt; eigvals(diag_matrix)
2-element Array{Float64,1}:
 1.0
 4.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L204-L227">source</a><div><pre><code class="language-none">eigvals(A, B) -&gt; values</code></pre><p>Computes the generalized eigenvalues of <code>A</code> and <code>B</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L472-L494">source</a><div><pre><code class="language-none">eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</code></pre><p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a <code>UnitRange</code> <code>irange</code> covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.</p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, 2:2)
1-element Array{Float64,1}:
 0.9999999999999996

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/symmetric.jl#L462-L486">source</a><div><pre><code class="language-none">eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</code></pre><p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a pair <code>vl</code> and <code>vu</code> for the lower and upper boundaries of the eigenvalues.</p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0000000000000009

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/symmetric.jl#L502-L525">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigvals!" href="#Base.LinAlg.eigvals!"><code>Base.LinAlg.eigvals!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigvals!(A; permute::Bool=true, scale::Bool=true) -&gt; values</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The input matrix <code>A</code> will not contain its eigenvalues after <code>eigvals!</code> is called on it - <code>A</code> is used as a workspace.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; eigvals!(A)
2-element Array{Float64,1}:
 -0.3722813232690143
  5.372281323269014

julia&gt; A
2×2 Array{Float64,2}:
 -0.372281  -1.0
  0.0        5.37228</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L161-L190">source</a><div><pre><code class="language-none">eigvals!(A, B) -&gt; values</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating copies.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The input matrices <code>A</code> and <code>B</code> will not contain their eigenvalues after <code>eigvals!</code> is called. They are used as workspaces.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; eigvals!(A, B)
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im

julia&gt; A
2×2 Array{Float64,2}:
 -0.0  -1.0
  1.0  -0.0

julia&gt; B
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L423-L460">source</a><div><pre><code class="language-none">eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>irange</code> is a range of eigenvalue <em>indices</em> to search for - for instance, the 2nd to 8th eigenvalues.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/symmetric.jl#L453-L458">source</a><div><pre><code class="language-none">eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.eigvals"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>vl</code> is the lower bound of the interval to search for eigenvalues, and <code>vu</code> is the upper bound.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/symmetric.jl#L493-L498">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigmax" href="#Base.LinAlg.eigmax"><code>Base.LinAlg.eigmax</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigmax(A; permute::Bool=true, scale::Bool=true)</code></pre><p>Return the largest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmax(A)
1.0

julia&gt; A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmax(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L235-L267">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigmin" href="#Base.LinAlg.eigmin"><code>Base.LinAlg.eigmin</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigmin(A; permute::Bool=true, scale::Bool=true)</code></pre><p>Return the smallest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmin(A)
-1.0

julia&gt; A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmin(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L276-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigvecs" href="#Base.LinAlg.eigvecs"><code>Base.LinAlg.eigvecs</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigvecs(A::SymTridiagonal[, eigvals]) -&gt; Matrix</code></pre><p>Return a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p><p>If the optional vector of eigenvalues <code>eigvals</code> is specified, <code>eigvecs</code> returns the specific corresponding eigenvectors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259

julia&gt; eigvecs(A)
3×3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia&gt; eigvecs(A, [1.])
3×1 Array{Float64,2}:
  0.8320502943378438
  4.263514128092366e-17
 -0.5547001962252291</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/tridiag.jl#L219-L254">source</a><div><pre><code class="language-none">eigvecs(A; permute::Bool=true, scale::Bool=true) -&gt; Matrix</code></pre><p>Return a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.) The <code>permute</code> and <code>scale</code> keywords are the same as for <a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L139-L154">source</a><div><pre><code class="language-none">eigvecs(A, B) -&gt; Matrix</code></pre><p>Return a matrix <code>M</code> whose columns are the generalized eigenvectors of <code>A</code> and <code>B</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvecs(A, B)
2×2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L500-L523">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigfact" href="#Base.LinAlg.eigfact"><code>Base.LinAlg.eigfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigfact(A; permute::Bool=true, scale::Bool=true) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F[:values]</code> and the eigenvectors in the columns of the matrix <code>F[:vectors]</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F[:vectors][:, k]</code>.)</p><p>The following functions are available for <code>Eigen</code> objects: <a href="linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="linalg.html#Base.LinAlg.det"><code>det</code></a>, and <a href="linalg.html#Base.LinAlg.isposdef"><code>isposdef</code></a>.</p><p>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F = eigfact([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Base.LinAlg.Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; F[:values]
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia&gt; F[:vectors]
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L68-L99">source</a><div><pre><code class="language-none">eigfact(A, B) -&gt; GeneralizedEigen</code></pre><p>Computes the generalized eigenvalue decomposition of <code>A</code> and <code>B</code>, returning a <code>GeneralizedEigen</code> factorization object <code>F</code> which contains the generalized eigenvalues in <code>F[:values]</code> and the generalized eigenvectors in the columns of the matrix <code>F[:vectors]</code>. (The <code>k</code>th generalized eigenvector can be obtained from the slice <code>F[:vectors][:, k]</code>.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; F = eigfact(A, B);

julia&gt; F[:values]
2-element Array{Complex{Float64},1}:
 0.0 + 1.0im
 0.0 - 1.0im

julia&gt; F[:vectors]
2×2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L350-L382">source</a><div><pre><code class="language-none">eigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F[:values]</code> and the eigenvectors in the columns of the matrix <code>F[:vectors]</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F[:vectors][:, k]</code>.)</p><p>The following functions are available for <code>Eigen</code> objects: <a href="linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="linalg.html#Base.LinAlg.det"><code>det</code></a>, and <a href="linalg.html#Base.LinAlg.isposdef"><code>isposdef</code></a>.</p><p>The <code>UnitRange</code> <code>irange</code> specifies indices of the sorted eigenvalues to search for.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If <code>irange</code> is not <code>1:n</code>, where <code>n</code> is the dimension of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/symmetric.jl#L399-L413">source</a><div><pre><code class="language-none">eigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; Eigen</code></pre><p>Computes the eigenvalue decomposition of <code>A</code>, returning an <code>Eigen</code> factorization object <code>F</code> which contains the eigenvalues in <code>F[:values]</code> and the eigenvectors in the columns of the matrix <code>F[:vectors]</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F[:vectors][:, k]</code>.)</p><p>The following functions are available for <code>Eigen</code> objects: <a href="linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="linalg.html#Base.LinAlg.det"><code>det</code></a>, and <a href="linalg.html#Base.LinAlg.isposdef"><code>isposdef</code></a>.</p><p><code>vl</code> is the lower bound of the window of eigenvalues to search for, and <code>vu</code> is the upper bound.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If [<code>vl</code>, <code>vu</code>] does not contain all eigenvalues of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/symmetric.jl#L423-L437">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.eigfact!" href="#Base.LinAlg.eigfact!"><code>Base.LinAlg.eigfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">eigfact!(A, [B])</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/eigen.jl#L32-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.hessfact" href="#Base.LinAlg.hessfact"><code>Base.LinAlg.hessfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hessfact(A) -&gt; Hessenberg</code></pre><p>Compute the Hessenberg decomposition of <code>A</code> and return a <code>Hessenberg</code> object. If <code>F</code> is the factorization object, the unitary matrix can be accessed with <code>F[:Q]</code> and the Hessenberg matrix with <code>F[:H]</code>. When <code>Q</code> is extracted, the resulting type is the <code>HessenbergQ</code> object, and may be converted to a regular matrix with <a href="base.html#Base.convert"><code>convert(Array, _)</code></a>  (or <code>Array(_)</code> for short).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; F = hessfact(A);

julia&gt; F[:Q] * F[:H] * F[:Q]&#39;
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/hessenberg.jl#L24-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.hessfact!" href="#Base.LinAlg.hessfact!"><code>Base.LinAlg.hessfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hessfact!(A) -&gt; Hessenberg</code></pre><p><code>hessfact!</code> is the same as <a href="linalg.html#Base.LinAlg.hessfact"><code>hessfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/hessenberg.jl#L14-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.schurfact" href="#Base.LinAlg.schurfact"><code>Base.LinAlg.schurfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">schurfact(A::StridedMatrix) -&gt; F::Schur</code></pre><p>Computes the Schur factorization of the matrix <code>A</code>. The (quasi) triangular Schur factor can be obtained from the <code>Schur</code> object <code>F</code> with either <code>F[:Schur]</code> or <code>F[:T]</code> and the orthogonal/unitary Schur vectors can be obtained with <code>F[:vectors]</code> or <code>F[:Z]</code> such that <code>A = F[:vectors] * F[:Schur] * F[:vectors]&#39;</code>. The eigenvalues of <code>A</code> can be obtained with <code>F[:values]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schurfact(A)
Base.LinAlg.Schur{Float64,Array{Float64,2}} with factors T and Z:
[3.0 9.0; 0.0 -2.0]
[0.961524 0.274721; -0.274721 0.961524]
and values:
[3.0, -2.0]

julia&gt; F[:vectors] * F[:Schur] * F[:vectors]&#39;
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L39-L66">source</a><div><pre><code class="language-none">schurfact(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</code></pre><p>Computes the Generalized Schur (or QZ) factorization of the matrices <code>A</code> and <code>B</code>. The (quasi) triangular Schur factors can be obtained from the <code>Schur</code> object <code>F</code> with <code>F[:S]</code> and <code>F[:T]</code>, the left unitary/orthogonal Schur vectors can be obtained with <code>F[:left]</code> or <code>F[:Q]</code> and the right unitary/orthogonal Schur vectors can be obtained with <code>F[:right]</code> or <code>F[:Z]</code> such that <code>A=F[:left]*F[:S]*F[:right]&#39;</code> and <code>B=F[:left]*F[:T]*F[:right]&#39;</code>. The generalized eigenvalues of <code>A</code> and <code>B</code> can be obtained with <code>F[:alpha]./F[:beta]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L203-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.schurfact!" href="#Base.LinAlg.schurfact!"><code>Base.LinAlg.schurfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">schurfact!(A::StridedMatrix) -&gt; F::Schur</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.schurfact"><code>schurfact</code></a> but uses the input argument <code>A</code> as workspace.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schurfact!(A)
Base.LinAlg.Schur{Float64,Array{Float64,2}} with factors T and Z:
[3.0 9.0; 0.0 -2.0]
[0.961524 0.274721; -0.274721 0.961524]
and values:
[3.0, -2.0]

julia&gt; A
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L12-L36">source</a><div><pre><code class="language-none">schurfact!(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.schurfact"><code>schurfact</code></a> but uses the input matrices <code>A</code> and <code>B</code> as workspace.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L195-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.schur" href="#Base.LinAlg.schur"><code>Base.LinAlg.schur</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">schur(A::StridedMatrix) -&gt; T::Matrix, Z::Matrix, λ::Vector</code></pre><p>Computes the Schur factorization of the matrix <code>A</code>. The methods return the (quasi) triangular Schur factor <code>T</code> and the orthogonal/unitary Schur vectors <code>Z</code> such that <code>A = Z * T * Z&#39;</code>. The eigenvalues of <code>A</code> are returned in the vector <code>λ</code>.</p><p>See <a href="linalg.html#Base.LinAlg.schurfact"><code>schurfact</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; T, Z, lambda = schur(A)
([3.0 9.0; 0.0 -2.0], [0.961524 0.274721; -0.274721 0.961524], [3.0, -2.0])

julia&gt; Z * Z&#39;
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia&gt; Z * T * Z&#39;
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L92-L121">source</a><div><pre><code class="language-none">schur(A::StridedMatrix, B::StridedMatrix) -&gt; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector</code></pre><p>See <a href="linalg.html#Base.LinAlg.schurfact"><code>schurfact</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L287-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ordschur" href="#Base.LinAlg.ordschur"><code>Base.LinAlg.ordschur</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</code></pre><p>Reorders the Schur factorization <code>F</code> of a matrix <code>A = Z*T*Z&#39;</code> according to the logical array <code>select</code> returning the reordered factorization <code>F</code> object. The selected eigenvalues appear in the leading diagonal of <code>F[:Schur]</code> and the corresponding leading columns of <code>F[:vectors]</code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code>select</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L144-L153">source</a><div><pre><code class="language-none">ordschur(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -&gt; T::StridedMatrix, Z::StridedMatrix, λ::Vector</code></pre><p>Reorders the Schur factorization of a real matrix <code>A = Z*T*Z&#39;</code> according to the logical array <code>select</code> returning the reordered matrices <code>T</code> and <code>Z</code> as well as the vector of eigenvalues <code>λ</code>. The selected eigenvalues appear in the leading diagonal of <code>T</code> and the corresponding leading columns of <code>Z</code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code>select</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L165-L174">source</a><div><pre><code class="language-none">ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</code></pre><p>Reorders the Generalized Schur factorization <code>F</code> of a matrix pair <code>(A, B) = (Q*S*Z&#39;, Q*T*Z&#39;)</code> according to the logical array <code>select</code> and returns a GeneralizedSchur object <code>F</code>. The selected eigenvalues appear in the leading diagonal of both <code>F[:S]</code> and <code>F[:T]</code>, and the left and right orthogonal/unitary Schur vectors are also reordered such that <code>(A, B) = F[:Q]*(F[:S], F[:T])*F[:Z]&#39;</code> still holds and the generalized eigenvalues of <code>A</code> and <code>B</code> can still be obtained with <code>F[:alpha]./F[:beta]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L231-L240">source</a><div><pre><code class="language-none">ordschur(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -&gt; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector</code></pre><p>Reorders the Generalized Schur factorization of a matrix pair <code>(A, B) = (Q*S*Z&#39;, Q*T*Z&#39;)</code> according to the logical array <code>select</code> and returns the matrices <code>S</code>, <code>T</code>, <code>Q</code>, <code>Z</code> and vectors <code>α</code> and <code>β</code>.  The selected eigenvalues appear in the leading diagonal of both <code>S</code> and <code>T</code>, and the left and right unitary/orthogonal Schur vectors are also reordered such that <code>(A, B) = Q*(S, T)*Z&#39;</code> still holds and the generalized eigenvalues of <code>A</code> and <code>B</code> can still be obtained with <code>α./β</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L253-L262">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ordschur!" href="#Base.LinAlg.ordschur!"><code>Base.LinAlg.ordschur!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.ordschur"><code>ordschur</code></a> but overwrites the factorization <code>F</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L133-L137">source</a><div><pre><code class="language-none">ordschur!(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -&gt; T::StridedMatrix, Z::StridedMatrix, λ::Vector</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.ordschur"><code>ordschur</code></a> but overwrites the input arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L157-L161">source</a><div><pre><code class="language-none">ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</code></pre><p>Same as <code>ordschur</code> but overwrites the factorization <code>F</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L219-L223">source</a><div><pre><code class="language-none">ordschur!(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -&gt; S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector</code></pre><p>Same as <a href="linalg.html#Base.LinAlg.ordschur"><code>ordschur</code></a> but overwrites the factorization the input arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/schur.jl#L244-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svdfact" href="#Base.LinAlg.svdfact"><code>Base.LinAlg.svdfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svdfact(A; full::Bool = false) -&gt; SVD</code></pre><p>Compute the singular value decomposition (SVD) of <code>A</code> and return an <code>SVD</code> object.</p><p><code>U</code>, <code>S</code>, <code>V</code> and <code>Vt</code> can be obtained from the factorization <code>F</code> with <code>F[:U]</code>, <code>F[:S]</code>, <code>F[:V]</code> and <code>F[:Vt]</code>, such that <code>A = U * Diagonal(S) * Vt</code>. The algorithm produces <code>Vt</code> and hence <code>Vt</code> is more efficient to extract than <code>V</code>. The singular values in <code>S</code> are sorted in descending order.</p><p>If <code>full = false</code> (default), a &quot;thin&quot; SVD is returned. For a <span>$M \times N$</span> matrix <code>A</code>, <code>U</code> is <span>$M \times M$</span> for a &quot;full&quot; SVD (<code>full = true</code>) and <span>$M \times \min(M, N)$</span> for a &quot;thin&quot; SVD.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svdfact(A);

julia&gt; F[:U] * Diagonal(F[:S]) * F[:Vt]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L62-L94">source</a><div><pre><code class="language-none">svdfact(A, B) -&gt; GeneralizedSVD</code></pre><p>Compute the generalized SVD of <code>A</code> and <code>B</code>, returning a <code>GeneralizedSVD</code> factorization object <code>F</code>, such that <code>A = F[:U]*F[:D1]*F[:R0]*F[:Q]&#39;</code> and <code>B = F[:V]*F[:D2]*F[:R0]*F[:Q]&#39;</code>.</p><p>For an M-by-N matrix <code>A</code> and P-by-N matrix <code>B</code>,</p><ul><li><p><code>F[:U]</code> is a M-by-M orthogonal matrix,</p></li><li><p><code>F[:V]</code> is a P-by-P orthogonal matrix,</p></li><li><p><code>F[:Q]</code> is a N-by-N orthogonal matrix,</p></li><li><p><code>F[:R0]</code> is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,</p></li><li><p><code>F[:D1]</code> is a M-by-(K+L) diagonal matrix with 1s in the first K entries,</p></li><li><p><code>F[:D2]</code> is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,</p></li></ul><p><code>K+L</code> is the effective numerical rank of the matrix <code>[A; B]</code>.</p><p>The entries of <code>F[:D1]</code> and <code>F[:D2]</code> are related, as explained in the LAPACK documentation for the <a href="http://www.netlib.org/lapack/lug/node36.html">generalized SVD</a> and the <a href="http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html">xGGSVD3</a> routine which is called underneath (in LAPACK 3.6.0 and newer).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; F = svdfact(A, B);

julia&gt; F[:U]*F[:D1]*F[:R0]*F[:Q]&#39;
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; F[:V]*F[:D2]*F[:R0]*F[:Q]&#39;
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L332-L380">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svdfact!" href="#Base.LinAlg.svdfact!"><code>Base.LinAlg.svdfact!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svdfact!(A; full::Bool = false) -&gt; SVD</code></pre><p><code>svdfact!</code> is the same as <a href="linalg.html#Base.LinAlg.svdfact"><code>svdfact</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svdfact!(A);

julia&gt; F[:U] * Diagonal(F[:S]) * F[:Vt]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; A
4×5 Array{Float64,2}:
 -2.23607   0.0   0.0  0.0  0.618034
  0.0      -3.0   1.0  0.0  0.0
  0.0       0.0   0.0  0.0  0.0
  0.0       0.0  -2.0  0.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L13-L44">source</a><div><pre><code class="language-none">svdfact!(A, B) -&gt; GeneralizedSVD</code></pre><p><code>svdfact!</code> is the same as <a href="linalg.html#Base.LinAlg.svdfact"><code>svdfact</code></a>, but modifies the arguments <code>A</code> and <code>B</code> in-place, instead of making copies.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; F = svdfact!(A, B);

julia&gt; F[:U]*F[:D1]*F[:R0]*F[:Q]&#39;
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; F[:V]*F[:D2]*F[:R0]*F[:Q]&#39;
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; A
2×2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia&gt; B
2×2 Array{Float64,2}:
 1.0  -0.0
 0.0  -1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L280-L320">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svd" href="#Base.LinAlg.svd"><code>Base.LinAlg.svd</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svd(A; full::Bool = false) -&gt; U, S, V</code></pre><p>Computes the SVD of <code>A</code>, returning <code>U</code>, vector <code>S</code>, and <code>V</code> such that <code>A == U * Diagonal(S) * V&#39;</code>. The singular values in <code>S</code> are sorted in descending order.</p><p>If <code>full = false</code> (default), a &quot;thin&quot; SVD is returned. For a <span>$M \times N$</span> matrix <code>A</code>, <code>U</code> is <span>$M \times M$</span> for a &quot;full&quot; SVD (<code>full = true</code>) and <span>$M \times \min(M, N)$</span> for a &quot;thin&quot; SVD.</p><p><code>svd</code> is a wrapper around <a href="linalg.html#Base.LinAlg.svdfact"><code>svdfact</code></a>, extracting all parts of the <code>SVD</code> factorization to a tuple. Direct use of <code>svdfact</code> is therefore more efficient.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; U, S, V = svd(A);

julia&gt; U * Diagonal(S) * V&#39;
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L126-L158">source</a><div><pre><code class="language-none">svd(A, B) -&gt; U, V, Q, D1, D2, R0</code></pre><p>Wrapper around <a href="linalg.html#Base.LinAlg.svdfact"><code>svdfact</code></a> extracting all parts of the factorization to a tuple. Direct use of <code>svdfact</code> is therefore generally more efficient. The function returns the generalized SVD of <code>A</code> and <code>B</code>, returning <code>U</code>, <code>V</code>, <code>Q</code>, <code>D1</code>, <code>D2</code>, and <code>R0</code> such that <code>A = U*D1*R0*Q&#39;</code> and <code>B = V*D2*R0*Q&#39;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; U, V, Q, D1, D2, R0 = svd(A, B);

julia&gt; U*D1*R0*Q&#39;
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; V*D2*R0*Q&#39;
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L390-L423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svdvals" href="#Base.LinAlg.svdvals"><code>Base.LinAlg.svdvals</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svdvals(A)</code></pre><p>Return the singular values of <code>A</code> in descending order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L228-L249">source</a><div><pre><code class="language-none">svdvals(A, B)</code></pre><p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>. See also <a href="linalg.html#Base.LinAlg.svdfact"><code>svdfact</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; svdvals(A, B)
2-element Array{Float64,1}:
 1.0
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L516-L539">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.svdvals!" href="#Base.LinAlg.svdvals!"><code>Base.LinAlg.svdvals!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">svdvals!(A)</code></pre><p>Return the singular values of <code>A</code>, saving space by overwriting the input. See also <a href="linalg.html#Base.LinAlg.svdvals"><code>svdvals</code></a> and <a href="linalg.html#Base.LinAlg.svdfact"><code>svdfact</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals!(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0

julia&gt; A
4×5 Array{Float64,2}:
 -2.23607   0.0   0.0  0.0  0.618034
  0.0      -3.0   1.0  0.0  0.0
  0.0       0.0   0.0  0.0  0.0
  0.0       0.0  -2.0  0.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L195-L224">source</a><div><pre><code class="language-none">svdvals!(A, B)</code></pre><p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>, saving space by overwriting <code>A</code> and <code>B</code>. See also <a href="linalg.html#Base.LinAlg.svdfact"><code>svdfact</code></a> and <a href="linalg.html#Base.LinAlg.svdvals"><code>svdvals</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; svdvals!(A, B)
2-element Array{Float64,1}:
 1.0
 1.0

julia&gt; A
2×2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia&gt; B
2×2 Array{Float64,2}:
 1.0  -0.0
 0.0  -1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/svd.jl#L470-L504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Givens" href="#Base.LinAlg.Givens"><code>Base.LinAlg.Givens</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinAlg.Givens(i1,i2,c,s) -&gt; G</code></pre><p>A Givens rotation linear operator. The fields <code>c</code> and <code>s</code> represent the cosine and sine of the rotation angle, respectively. The <code>Givens</code> type supports left multiplication <code>G*A</code> and conjugated transpose right multiplication <code>A*G&#39;</code>. The type doesn&#39;t have a <code>size</code> and can therefore be multiplied with matrices of arbitrary size as long as <code>i2&lt;=size(A,2)</code> for <code>G*A</code> or <code>i2&lt;=size(A,1)</code> for <code>A*G&#39;</code>.</p><p>See also: <a href="linalg.html#Base.LinAlg.givens"><code>givens</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/givens.jl#L16-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.givens" href="#Base.LinAlg.givens"><code>Base.LinAlg.givens</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -&gt; (G::Givens, r::T)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that for any vector <code>x</code> where</p><pre><code class="language-none">x[i1] = f
x[i2] = g</code></pre><p>the result of the multiplication</p><pre><code class="language-none">y = G*x</code></pre><p>has the property that</p><pre><code class="language-none">y[i1] = r
y[i2] = 0</code></pre><p>See also: <a href="linalg.html#Base.LinAlg.Givens"><code>LinAlg.Givens</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/givens.jl#L234-L254">source</a><div><pre><code class="language-none">givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -&gt; (G::Givens, r)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p><pre><code class="language-none">B = G*A</code></pre><p>has the property that</p><pre><code class="language-none">B[i1,j] = r
B[i2,j] = 0</code></pre><p>See also: <a href="linalg.html#Base.LinAlg.Givens"><code>LinAlg.Givens</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/givens.jl#L266-L280">source</a><div><pre><code class="language-none">givens(x::AbstractVector, i1::Integer, i2::Integer) -&gt; (G::Givens, r)</code></pre><p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p><pre><code class="language-none">B = G*x</code></pre><p>has the property that</p><pre><code class="language-none">B[i1] = r
B[i2] = 0</code></pre><p>See also: <a href="linalg.html#Base.LinAlg.Givens"><code>LinAlg.Givens</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/givens.jl#L285-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.triu" href="#Base.LinAlg.triu"><code>Base.LinAlg.triu</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">triu(M)</code></pre><p>Upper triangle of a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L117-L138">source</a><div><pre><code class="language-none">triu(M, k::Integer)</code></pre><p>Returns the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a,3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; triu(a,-3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L165-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.triu!" href="#Base.LinAlg.triu!"><code>Base.LinAlg.triu!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">triu!(M)</code></pre><p>Upper triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="linalg.html#Base.LinAlg.triu"><code>triu</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L227-L232">source</a><div><pre><code class="language-none">triu!(M, k::Integer)</code></pre><p>Return the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; triu!(M, 1)
5×5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L158-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.tril" href="#Base.LinAlg.tril"><code>Base.LinAlg.tril</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tril(M)</code></pre><p>Lower triangle of a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L141-L162">source</a><div><pre><code class="language-none">tril(M, k::Integer)</code></pre><p>Returns the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,-3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L196-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.tril!" href="#Base.LinAlg.tril!"><code>Base.LinAlg.tril!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tril!(M)</code></pre><p>Lower triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="linalg.html#Base.LinAlg.tril"><code>tril</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L235-L240">source</a><div><pre><code class="language-none">tril!(M, k::Integer)</code></pre><p>Return the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; tril!(M, 2)
5×5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L202-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.diagind" href="#Base.LinAlg.diagind"><code>Base.LinAlg.diagind</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diagind(M, k::Integer=0)</code></pre><p>An <code>AbstractRange</code> giving the indices of the <code>k</code>th diagonal of the matrix <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diagind(A,-1)
2:4:6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L253-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.diag" href="#Base.LinAlg.diag"><code>Base.LinAlg.diag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diag(M, k::Integer=0)</code></pre><p>The <code>k</code>th diagonal of a matrix, as a vector.</p><p>See also: <a href="linalg.html#Base.LinAlg.diagm"><code>diagm</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diag(A,1)
2-element Array{Int64,1}:
 2
 6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L272-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.diagm" href="#Base.LinAlg.diagm"><code>Base.LinAlg.diagm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)</code></pre><p>Construct a square matrix from <code>Pair</code>s of diagonals and vectors. Vector <code>kv.second</code> will be placed on the <code>kv.first</code> diagonal. <code>diagm</code> constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see <a href="linalg.html#Base.LinAlg.Diagonal"><code>Diagonal</code></a>, <a href="linalg.html#Base.LinAlg.Bidiagonal"><code>Bidiagonal</code></a> <a href="linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a> and <a href="linalg.html#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a>.</p><p>See also: <a href="arrays.html#Base.SparseArrays.spdiagm"><code>spdiagm</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; diagm(1 =&gt; [1,2,3])
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0

julia&gt; diagm(1 =&gt; [1,2,3], -1 =&gt; [4,5])
4×4 Array{Int64,2}:
 0  1  0  0
 4  0  2  0
 0  5  0  3
 0  0  0  0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L295-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.scale!" href="#Base.LinAlg.scale!"><code>Base.LinAlg.scale!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">scale!(A, b)
scale!(b, A)</code></pre><p>Scale an array <code>A</code> by a scalar <code>b</code> overwriting <code>A</code> in-place.</p><p>If <code>A</code> is a matrix and <code>b</code> is a vector, then <code>scale!(A,b)</code> scales each column <code>i</code> of <code>A</code> by <code>b[i]</code> (similar to <code>A*Diagonal(b)</code>), while <code>scale!(b,A)</code> scales each row <code>i</code> of <code>A</code> by <code>b[i]</code> (similar to <code>Diagonal(b)*A</code>), again operating in-place on <code>A</code>. An <code>InexactError</code> exception is thrown if the scaling produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; scale!(a,b)
2×2 Array{Int64,2}:
 1  4
 3  8

julia&gt; a = [1 2; 3 4];

julia&gt; b = [1; 2];

julia&gt; scale!(b,a)
2×2 Array{Int64,2}:
 1  2
 6  8</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L45-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.rank" href="#Base.LinAlg.rank"><code>Base.LinAlg.rank</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rank(A[, tol::Real])</code></pre><p>Compute the rank of a matrix by counting how many singular values of <code>A</code> have magnitude greater than <code>tol*σ₁</code> where <code>σ₁</code> is <code>A</code>&#39;s largest singular values. By default, the value of <code>tol</code> is the smallest dimension of <code>A</code> multiplied by the <a href="dates.html#Base.eps"><code>eps</code></a> of the <a href="collections.html#Base.eltype"><code>eltype</code></a> of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rank(Matrix(I, 3, 3))
3

julia&gt; rank(diagm(0 =&gt; [1, 0, 2]))
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), 0.1)
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), 0.00001)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L728-L751">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(A::AbstractArray, p::Real=2)</code></pre><p>Compute the <code>p</code>-norm of a vector or the operator norm of a matrix <code>A</code>, defaulting to the 2-norm.</p><pre><code class="language-none">norm(A::AbstractVector, p::Real=2)</code></pre><p>For vectors, this is equivalent to <a href="linalg.html#Base.LinAlg.vecnorm"><code>vecnorm</code></a> and equal to:</p><div>\[\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\]</div><p>with <span>$a_i$</span> the entries of <span>$A$</span> and <span>$n$</span> its length.</p><p><code>p</code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code>norm(A, Inf)</code> returns the largest value in <code>abs(A)</code>, whereas <code>norm(A, -Inf)</code> returns the smallest.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia&gt; norm(v)
7.0

julia&gt; norm(v, Inf)
6.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L492-L524">source</a><div><pre><code class="language-none">norm(A::AbstractMatrix, p::Real=2)</code></pre><p>For matrices, the matrix norm induced by the vector <code>p</code>-norm is used, where valid values of <code>p</code> are <code>1</code>, <code>2</code>, or <code>Inf</code>. (Note that for sparse matrices, <code>p=2</code> is currently not implemented.) Use <a href="linalg.html#Base.LinAlg.vecnorm"><code>vecnorm</code></a> to compute the Frobenius norm.</p><p>When <code>p=1</code>, the matrix norm is the maximum absolute column sum of <code>A</code>:</p><div>\[\|A\|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} |\]</div><p>with <span>$a_{ij}$</span> the entries of <span>$A$</span>, and <span>$m$</span> and <span>$n$</span> its dimensions.</p><p>When <code>p=2</code>, the matrix norm is the spectral norm, equal to the largest singular value of <code>A</code>.</p><p>When <code>p=Inf</code>, the matrix norm is the maximum absolute row sum of <code>A</code>:</p><div>\[\|A\|_\infty = \max_{1 ≤ i ≤ m} \sum _{j=1}^n | a_{ij} |\]</div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 -2 -3; 2 3 -1]
2×3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia&gt; norm(A, Inf)
6.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L527-L558">source</a><div><pre><code class="language-none">norm(x::Number, p::Real=2)</code></pre><p>For numbers, return <span>$\left( |x|^p \right)^{1/p}$</span>. This is equivalent to <a href="linalg.html#Base.LinAlg.vecnorm"><code>vecnorm</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L571-L576">source</a><div><pre><code class="language-none">norm(A::RowVector, q::Real=2)</code></pre><p>For row vectors, return the <span>$q$</span>-norm of <code>A</code>, which is equivalent to the p-norm with value <code>p = q/(q-1)</code>. They coincide at <code>p = q = 2</code>.</p><p>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the inner product, and the result is consistent with the p-norm of <code>1 × n</code> matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1; im];

julia&gt; vc = v&#39;;

julia&gt; norm(vc, 1)
1.0

julia&gt; norm(v, 1)
2.0

julia&gt; norm(vc, 2)
1.4142135623730951

julia&gt; norm(v, 2)
1.4142135623730951

julia&gt; norm(vc, Inf)
2.0

julia&gt; norm(v, Inf)
1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L581-L615">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.vecnorm" href="#Base.LinAlg.vecnorm"><code>Base.LinAlg.vecnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vecnorm(A, p::Real=2)</code></pre><p>For any iterable container <code>A</code> (including arrays of any dimension) of numbers (or any element type for which <code>norm</code> is defined), compute the <code>p</code>-norm (defaulting to <code>p=2</code>) as if <code>A</code> were a vector of the corresponding length.</p><p>The <code>p</code>-norm is defined as:</p><div>\[\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\]</div><p>with <span>$a_i$</span> the entries of <span>$A$</span> and <span>$n$</span> its length.</p><p><code>p</code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code>vecnorm(A, Inf)</code> returns the largest value in <code>abs(A)</code>, whereas <code>vecnorm(A, -Inf)</code> returns the smallest. If <code>A</code> is a matrix and <code>p=2</code>, then this is equivalent to the Frobenius norm.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vecnorm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia&gt; vecnorm([1 2 3 4 5 6 7 8 9])
16.881943016134134</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L381-L407">source</a><div><pre><code class="language-none">vecnorm(x::Number, p::Real=2)</code></pre><p>For numbers, return <span>$\left( |x|^p \right) ^{1/p}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vecnorm(2, 1)
2

julia&gt; vecnorm(-2, 1)
2

julia&gt; vecnorm(2, 2)
2

julia&gt; vecnorm(-2, 2)
2

julia&gt; vecnorm(2, Inf)
2

julia&gt; vecnorm(-2, Inf)
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L425-L450">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.normalize!" href="#Base.LinAlg.normalize!"><code>Base.LinAlg.normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">normalize!(v::AbstractVector, p::Real=2)</code></pre><p>Normalize the vector <code>v</code> in-place so that its <code>p</code>-norm equals unity, i.e. <code>norm(v, p) == 1</code>. See also <a href="linalg.html#Base.LinAlg.normalize"><code>normalize</code></a> and <a href="linalg.html#Base.LinAlg.vecnorm"><code>vecnorm</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1430-L1436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.normalize" href="#Base.LinAlg.normalize"><code>Base.LinAlg.normalize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">normalize(v::AbstractVector, p::Real=2)</code></pre><p>Normalize the vector <code>v</code> so that its <code>p</code>-norm equals unity, i.e. <code>norm(v, p) == vecnorm(v, p) == 1</code>. See also <a href="linalg.html#Base.LinAlg.normalize!"><code>normalize!</code></a> and <a href="linalg.html#Base.LinAlg.vecnorm"><code>vecnorm</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1,2,4];

julia&gt; b = normalize(a)
3-element Array{Float64,1}:
 0.2182178902359924
 0.4364357804719848
 0.8728715609439696

julia&gt; norm(b)
1.0

julia&gt; c = normalize(a, 1)
3-element Array{Float64,1}:
 0.14285714285714285
 0.2857142857142857
 0.5714285714285714

julia&gt; norm(c, 1)
1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1459-L1488">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cond" href="#Base.LinAlg.cond"><code>Base.LinAlg.cond</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cond(M, p::Real=2)</code></pre><p>Condition number of the matrix <code>M</code>, computed using the operator <code>p</code>-norm. Valid values for <code>p</code> are <code>1</code>, <code>2</code> (default), or <code>Inf</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1341-L1346">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.condskeel" href="#Base.LinAlg.condskeel"><code>Base.LinAlg.condskeel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">condskeel(M, [x, p::Real=Inf])</code></pre><div>\[\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\
\kappa_S(M, x, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\]</div><p>Skeel condition number <span>$\kappa_S$</span> of the matrix <code>M</code>, optionally with respect to the vector <code>x</code>, as computed using the operator <code>p</code>-norm. <span>$\left\vert M \right\vert$</span> denotes the matrix of (entry wise) absolute values of <span>$M$</span>; <span>$\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert$</span>. Valid values for <code>p</code> are <code>1</code>, <code>2</code> and <code>Inf</code> (default).</p><p>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L894-L910">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.trace" href="#Base.LinAlg.trace"><code>Base.LinAlg.trace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trace(M)</code></pre><p>Matrix trace. Sums the diagonal elements of <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; trace(A)
5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L758-L773">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.det" href="#Base.LinAlg.det"><code>Base.LinAlg.det</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">det(M)</code></pre><p>Matrix determinant.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia&gt; det(M)
2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1303-L1318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.logdet" href="#Base.LinAlg.logdet"><code>Base.LinAlg.logdet</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logdet(M)</code></pre><p>Log of matrix determinant. Equivalent to <code>log(det(M))</code>, but may provide increased accuracy and/or speed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia&gt; logdet(M)
0.6931471805599453

julia&gt; logdet(Matrix(I, 3, 3))
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1361-L1380">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.logabsdet" href="#Base.LinAlg.logabsdet"><code>Base.LinAlg.logabsdet</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logabsdet(M)</code></pre><p>Log of absolute value of matrix determinant. Equivalent to <code>(log(abs(det(M))), sign(det(M)))</code>, but may provide increased accuracy and/or speed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [-1. 0.; 0. 1.]
2×2 Array{Float64,2}:
 -1.0  0.0
  0.0  1.0

julia&gt; det(A)
-1.0

julia&gt; logabsdet(A)
(0.0, -1.0)

julia&gt; B = [2. 0.; 0. 1.]
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  1.0

julia&gt; det(B)
2.0

julia&gt; logabsdet(B)
(0.6931471805599453, 1.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1328-L1358">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.inv-Tuple{AbstractArray{T,2} where T}" href="#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">inv(M)</code></pre><p>Matrix inverse. Computes matrix <code>N</code> such that <code>M * N = I</code>, where <code>I</code> is the identity matrix. Computed by solving the left-division <code>N = M \ I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [2 5; 1 3]
2×2 Array{Int64,2}:
 2  5
 1  3

julia&gt; N = inv(M)
2×2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia&gt; M*N == N*M == Matrix(I, 2, 2)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L785-L808">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.pinv" href="#Base.LinAlg.pinv"><code>Base.LinAlg.pinv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pinv(M[, tol::Real])</code></pre><p>Computes the Moore-Penrose pseudoinverse.</p><p>For matrices <code>M</code> with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, <code>tol</code>.</p><p>The optimal choice of <code>tol</code> varies both with the value of <code>M</code> and the intended application of the pseudoinverse. The default value of <code>tol</code> is <code>eps(real(float(one(eltype(M)))))*maximum(size(A))</code>, which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, <code>tol = sqrt(eps(real(float(one(eltype(M))))))</code> is recommended.</p><p>For more information, see <a href="#footnote-issue8859">[issue8859]</a>, <a href="#footnote-B96">[B96]</a>, <a href="#footnote-S84">[S84]</a>, <a href="#footnote-KY88">[KY88]</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1.5 1.3; 1.2 1.9]
2×2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia&gt; N = pinv(M)
2×2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia&gt; M * N
2×2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0</code></pre><div class="footnote" id="footnote-issue8859"><a href="#footnote-issue8859"><strong>[issue8859]</strong></a><p>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</p></div><div class="footnote" id="footnote-B96"><a href="#footnote-B96"><strong>[B96]</strong></a><p>Åke Björck, &quot;Numerical Methods for Least Squares Problems&quot;,  SIAM Press, Philadelphia, 1996, &quot;Other Titles in Applied Mathematics&quot;, Vol. 51. <a href="http://epubs.siam.org/doi/book/10.1137/1.9781611971484">doi:10.1137/1.9781611971484</a></p></div><div class="footnote" id="footnote-S84"><a href="#footnote-S84"><strong>[S84]</strong></a><p>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. <a href="http://epubs.siam.org/doi/abs/10.1137/0905030">doi:10.1137/0905030</a></p></div><div class="footnote" id="footnote-KY88"><a href="#footnote-KY88"><strong>[KY88]</strong></a><p>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. <a href="http://dx.doi.org/10.1109/29.1585">doi:10.1109/29.1585</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1228-L1271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.nullspace" href="#Base.LinAlg.nullspace"><code>Base.LinAlg.nullspace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nullspace(M)</code></pre><p>Basis for nullspace of <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; M = [1 0 0; 0 1 0; 0 0 0]
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia&gt; nullspace(M)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1312-L1331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repmat" href="#Base.repmat"><code>Base.repmat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">repmat(A, m::Integer, n::Integer=1)</code></pre><p>Construct a matrix by repeating the given matrix (or vector) <code>m</code> times in dimension 1 and <code>n</code> times in dimension 2.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repmat([1, 2, 3], 2)
6-element Array{Int64,1}:
 1
 2
 3
 1
 2
 3

julia&gt; repmat([1, 2, 3], 2, 3)
6×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/abstractarraymath.jl#L243-L269">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">kron(A, B)</code></pre><p>Kronecker tensor product of two vectors or two matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; B = [im 1; 1 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia&gt; kron(A, B)
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L353-L377">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.SparseArrays.blkdiag" href="#Base.SparseArrays.blkdiag"><code>Base.SparseArrays.blkdiag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">blkdiag(A...)</code></pre><p>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; blkdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))
5×5 SparseMatrixCSC{Int64,Int64} with 5 stored entries:
  [1, 1]  =  2
  [2, 2]  =  2
  [3, 3]  =  2
  [4, 4]  =  4
  [5, 5]  =  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/sparse/sparsematrix.jl#L3089-L3104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.linreg" href="#Base.LinAlg.linreg"><code>Base.LinAlg.linreg</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linreg(x, y)</code></pre><p>Perform simple linear regression using Ordinary Least Squares. Returns <code>a</code> and <code>b</code> such that <code>a + b*x</code> is the closest straight line to the given points <code>(x, y)</code>, i.e., such that the squared error between <code>y</code> and <code>a + b*x</code> is minimized.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using PyPlot
x = 1.0:12.0
y = [5.5, 6.3, 7.6, 8.8, 10.9, 11.79, 13.48, 15.02, 17.77, 20.81, 22.0, 22.99]
a, b = linreg(x, y)          # Linear regression
plot(x, y, &quot;o&quot;)              # Plot (x, y) points
plot(x, a + b*x)             # Plot line determined by linear regression</code></pre><p>See also:</p><p><code>\</code>, <a href="math.html#Base.cov"><code>cov</code></a>, <a href="math.html#Base.std"><code>std</code></a>, <a href="math.html#Base.mean"><code>mean</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1136-L1157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}" href="#Base.exp-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">exp(A::AbstractMatrix)</code></pre><p>Compute the matrix exponential of <code>A</code>, defined by</p><div>\[e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\]</div><p>For symmetric or Hermitian <code>A</code>, an eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used, otherwise the scaling and squaring algorithm (see <a href="#footnote-H05">[H05]</a>) is chosen.</p><div class="footnote" id="footnote-H05"><a href="#footnote-H05"><strong>[H05]</strong></a><p>Nicholas J. Higham, &quot;The squaring and scaling method for the matrix exponential revisited&quot;, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. <a href="http://dx.doi.org/10.1137/090768539">doi:10.1137/090768539</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Matrix(1.0I, 2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia&gt; exp(A)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L472-L498">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.log-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.log-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.log</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">log(A{T}::StridedMatrix{T})</code></pre><p>If <code>A</code> has no negative real eigenvalue, compute the principal matrix logarithm of <code>A</code>, i.e. the unique matrix <span>$X$</span> such that <span>$e^X = A$</span> and <span>$-\pi &lt; Im(\lambda) &lt; \pi$</span> for all the eigenvalues <span>$\lambda$</span> of <span>$X$</span>. If <code>A</code> has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used, if <code>A</code> is triangular an improved version of the inverse scaling and squaring method is employed (see <a href="#footnote-AH12">[AH12]</a> and <a href="#footnote-AHR13">[AHR13]</a>). For general matrices, the complex Schur form (<a href="linalg.html#Base.LinAlg.schur"><code>schur</code></a>) is computed and the triangular algorithm is used on the triangular factor.</p><div class="footnote" id="footnote-AH12"><a href="#footnote-AH12"><strong>[AH12]</strong></a><p>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse  scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. <a href="http://dx.doi.org/10.1137/110852553">doi:10.1137/110852553</a></p></div><div class="footnote" id="footnote-AHR13"><a href="#footnote-AHR13"><strong>[AHR13]</strong></a><p>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fréchet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. <a href="http://dx.doi.org/10.1137/120885991">doi:10.1137/120885991</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Matrix(2.7182818*I, 2, 2)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia&gt; log(A)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L597-L627">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sqrt-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}" href="#Base.sqrt-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sqrt(A::AbstractMatrix)</code></pre><p>If <code>A</code> has no negative real eigenvalues, compute the principal matrix square root of <code>A</code>, that is the unique matrix <span>$X$</span> with eigenvalues having positive real part such that <span>$X^2 = A$</span>. Otherwise, a nonprincipal square root is returned.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method <a href="#footnote-BH83">[BH83]</a>, which computes the complex Schur form (<a href="linalg.html#Base.LinAlg.schur"><code>schur</code></a>) and then the complex square root of the triangular factor.</p><div class="footnote" id="footnote-BH83"><a href="#footnote-BH83"><strong>[BH83]</strong></a><p>Åke Björck and Sven Hammarling, &quot;A Schur method for the square root of a matrix&quot;, Linear Algebra and its Applications, 52-53, 1983, 127-140. <a href="http://dx.doi.org/10.1016/0024-3795(83)80010-X">doi:10.1016/0024-3795(83)80010-X</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 0; 0 4]
2×2 Array{Int64,2}:
 4  0
 0  4

julia&gt; sqrt(A)
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L656-L686">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cos-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}" href="#Base.cos-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>Base.cos</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cos(A::AbstractMatrix)</code></pre><p>Compute the matrix cosine of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the cosine. Otherwise, the cosine is determined by calling <a href="linalg.html#Base.exp-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}"><code>exp</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cos(ones(2, 2))
2×2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L730-L745">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sin-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}" href="#Base.sin-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>Base.sin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sin(A::AbstractMatrix)</code></pre><p>Compute the matrix sine of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the sine. Otherwise, the sine is determined by calling <a href="linalg.html#Base.exp-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}"><code>exp</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sin(ones(2, 2))
2×2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L763-L778">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sincos-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}" href="#Base.Math.sincos-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>Base.Math.sincos</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sincos(A::AbstractMatrix)</code></pre><p>Compute the matrix sine and cosine of a square matrix <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; S, C = sincos(ones(2, 2));

julia&gt; S
2×2 Array{Float64,2}:
 0.454649  0.454649
 0.454649  0.454649

julia&gt; C
2×2 Array{Float64,2}:
  0.291927  -0.708073
 -0.708073   0.291927</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L800-L819">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.tan-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}" href="#Base.tan-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>Base.tan</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tan(A::AbstractMatrix)</code></pre><p>Compute the matrix tangent of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the tangent. Otherwise, the tangent is determined by calling <a href="linalg.html#Base.exp-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}"><code>exp</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; tan(ones(2, 2))
2×2 Array{Float64,2}:
 -1.09252  -1.09252
 -1.09252  -1.09252</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L849-L864">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sec-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.sec-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.sec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sec(A::AbstractMatrix)</code></pre><p>Compute the matrix secant of a square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1075-L1079">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.csc-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.csc-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.csc</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">csc(A::AbstractMatrix)</code></pre><p>Compute the matrix cosecant of a square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1075-L1079">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.cot-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.cot-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.cot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cot(A::AbstractMatrix)</code></pre><p>Compute the matrix cotangent of a square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1075-L1079">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.cosh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.cosh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.cosh</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cosh(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic cosine of a square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L874-L878">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sinh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.sinh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.sinh</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sinh(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic sine of a square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L888-L892">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.tanh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.tanh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.tanh</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tanh(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic tangent of a square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L902-L906">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.sech-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.sech-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.sech</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sech(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic secant of square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1080-L1084">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.csch-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.csch-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.csch</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">csch(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic cosecant of square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1080-L1084">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.coth-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.coth-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.coth</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">coth(A::AbstractMatrix)</code></pre><p>Compute the matrix hyperbolic cotangent of square matrix <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1080-L1084">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.acos-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.acos-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.acos</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">acos(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix cosine of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using <a href="linalg.html#Base.log-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>log</code></a> and <a href="linalg.html#Base.sqrt-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>sqrt</code></a>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_1">[AH16_1]</a>.</p><div class="footnote" id="footnote-AH16_1"><a href="#footnote-AH16_1"><strong>[AH16_1]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; acos(cos([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5-8.32667e-17im  0.1-2.77556e-17im
 -0.2+2.77556e-16im  0.3-3.46945e-16im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L922-L941">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asin-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.asin-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.asin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">asin(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix sine of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using <a href="linalg.html#Base.log-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>log</code></a> and <a href="linalg.html#Base.sqrt-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>sqrt</code></a>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_2">[AH16_2]</a>.</p><div class="footnote" id="footnote-AH16_2"><a href="#footnote-AH16_2"><strong>[AH16_2]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; asin(sin([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5-4.16334e-17im  0.1-5.55112e-17im
 -0.2+9.71445e-17im  0.3-1.249e-16im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L953-L972">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.atan-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.atan-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.atan</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">atan(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix tangent of a square matrix <code>A</code>.</p><p>If <code>A</code> is symmetric or Hermitian, its eigendecomposition (<a href="linalg.html#Base.LinAlg.eigfact"><code>eigfact</code></a>) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using <a href="linalg.html#Base.log-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>log</code></a>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_3">[AH16_3]</a>.</p><div class="footnote" id="footnote-AH16_3"><a href="#footnote-AH16_3"><strong>[AH16_3]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; atan(tan([0.5 0.1; -0.2 0.3]))
2×2 Array{Complex{Float64},2}:
  0.5+1.38778e-17im  0.1-2.77556e-17im
 -0.2+6.93889e-17im  0.3-4.16334e-17im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L984-L1003">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.asec-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.asec-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.asec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">asec(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix secant of <code>A</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1094-L1096">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acsc-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.acsc-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.acsc</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">acsc(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix cosecant of <code>A</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1094-L1096">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acot-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.acot-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.acot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">acot(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix cotangent of <code>A</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1094-L1096">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.acosh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.acosh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.acosh</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">acosh(A::AbstractMatrix)</code></pre><p>Compute the inverse hyperbolic matrix cosine of a square matrix <code>A</code>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_4">[AH16_4]</a>.</p><div class="footnote" id="footnote-AH16_4"><a href="#footnote-AH16_4"><strong>[AH16_4]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1014-L1021">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asinh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.asinh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.asinh</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">asinh(A::AbstractMatrix)</code></pre><p>Compute the inverse hyperbolic matrix sine of a square matrix <code>A</code>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_5">[AH16_5]</a>.</p><div class="footnote" id="footnote-AH16_5"><a href="#footnote-AH16_5"><strong>[AH16_5]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1033-L1040">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.atanh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.atanh-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.atanh</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">atanh(A::AbstractMatrix)</code></pre><p>Compute the inverse hyperbolic matrix tangent of a square matrix <code>A</code>.  For the theory and logarithmic formulas used to compute this function, see <a href="#footnote-AH16_6">[AH16_6]</a>.</p><div class="footnote" id="footnote-AH16_6"><a href="#footnote-AH16_6"><strong>[AH16_6]</strong></a><p>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1051-L1058">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.asech-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.asech-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.asech</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">asech(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix hyperbolic secant of <code>A</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1097-L1099">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acsch-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.acsch-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.acsch</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">acsch(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix hyperbolic cosecant of <code>A</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1097-L1099">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Math.acoth-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}" href="#Base.Math.acoth-Tuple{Union{DenseArray{T,2}, Base.ReinterpretArray{T,2,S,A} where S, Base.ReshapedArray{T,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{T,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where T}"><code>Base.Math.acoth</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">acoth(A::AbstractMatrix)</code></pre><p>Compute the inverse matrix hyperbolic cotangent of <code>A</code>. </p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1097-L1099">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.lyap" href="#Base.LinAlg.lyap"><code>Base.LinAlg.lyap</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lyap(A, C)</code></pre><p>Computes the solution <code>X</code> to the continuous Lyapunov equation <code>AX + XA&#39; + C = 0</code>, where no eigenvalue of <code>A</code> has a zero real part and no two eigenvalues are negative complex conjugates of each other.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia&gt; X = lyap(A, B)
2×2 Array{Float64,2}:
  0.5  -0.5
 -0.5   0.25

julia&gt; A*X + X*A&#39; + B
2×2 Array{Float64,2}:
 0.0          6.66134e-16
 6.66134e-16  8.88178e-16</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1413-L1442">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.sylvester" href="#Base.LinAlg.sylvester"><code>Base.LinAlg.sylvester</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sylvester(A, B, C)</code></pre><p>Computes the solution <code>X</code> to the Sylvester equation <code>AX + XB + C = 0</code>, where <code>A</code>, <code>B</code> and <code>C</code> have compatible dimensions and <code>A</code> and <code>-B</code> have no eigenvalues with equal real part.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia&gt; C = [1. 2.; -2. 1]
2×2 Array{Float64,2}:
  1.0  2.0
 -2.0  1.0

julia&gt; X = sylvester(A, B, C)
2×2 Array{Float64,2}:
 -4.46667   1.93333
  3.73333  -1.8

julia&gt; A*X + X*B + C
2×2 Array{Float64,2}:
  2.66454e-15  1.77636e-15
 -3.77476e-15  4.44089e-16</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L1365-L1398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.issuccess" href="#Base.LinAlg.issuccess"><code>Base.LinAlg.issuccess</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">issuccess(F::Factorization)</code></pre><p>Test that a factorization of a matrix succeeded.</p><pre><code class="language-julia-repl">julia&gt; F = cholfact([1 0; 0 1]);

julia&gt; LinAlg.issuccess(F)
true

julia&gt; F = lufact([1 0; 0 0]);

julia&gt; LinAlg.issuccess(F)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/factorization.jl#L19-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.issymmetric" href="#Base.LinAlg.issymmetric"><code>Base.LinAlg.issymmetric</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">issymmetric(A) -&gt; Bool</code></pre><p>Test whether a matrix is symmetric.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; issymmetric(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; issymmetric(b)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L915-L938">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.isposdef" href="#Base.LinAlg.isposdef"><code>Base.LinAlg.isposdef</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isposdef(A) -&gt; Bool</code></pre><p>Test whether a matrix is positive definite by trying to perform a Cholesky factorization of <code>A</code>. See also <a href="linalg.html#Base.LinAlg.isposdef!"><code>isposdef!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia&gt; isposdef(A)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L94-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.isposdef!" href="#Base.LinAlg.isposdef!"><code>Base.LinAlg.isposdef!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isposdef!(A) -&gt; Bool</code></pre><p>Test whether a matrix is positive definite by trying to perform a Cholesky factorization of <code>A</code>, overwriting <code>A</code> in the process. See also <a href="linalg.html#Base.LinAlg.isposdef"><code>isposdef</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1. 2.; 2. 50.];

julia&gt; isposdef!(A)
true

julia&gt; A
2×2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L72-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.istril" href="#Base.LinAlg.istril"><code>Base.LinAlg.istril</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">istril(A::AbstractMatrix, k::Integer = 0) -&gt; Bool</code></pre><p>Test whether <code>A</code> is lower triangular starting from the <code>k</code>th superdiagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istril(a)
false

julia&gt; istril(a, 1)
true

julia&gt; b = [1 0; -im -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia&gt; istril(b)
true

julia&gt; istril(b, -1)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1034-L1063">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.istriu" href="#Base.LinAlg.istriu"><code>Base.LinAlg.istriu</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">istriu(A::AbstractMatrix, k::Integer = 0) -&gt; Bool</code></pre><p>Test whether <code>A</code> is upper triangular starting from the <code>k</code>th superdiagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istriu(a)
false

julia&gt; istriu(a, -1)
true

julia&gt; b = [1 im; 0 -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia&gt; istriu(b)
true

julia&gt; istriu(b, 1)
false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L993-L1022">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.isdiag" href="#Base.LinAlg.isdiag"><code>Base.LinAlg.isdiag</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isdiag(A) -&gt; Bool</code></pre><p>Test whether a matrix is diagonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; isdiag(a)
false

julia&gt; b = [im 0; 0 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia&gt; isdiag(b)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1108-L1131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ishermitian" href="#Base.LinAlg.ishermitian"><code>Base.LinAlg.ishermitian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ishermitian(A) -&gt; Bool</code></pre><p>Test whether a matrix is Hermitian.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; ishermitian(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; ishermitian(b)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L954-L977">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.RowVector" href="#Base.LinAlg.RowVector"><code>Base.LinAlg.RowVector</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RowVector(vector)</code></pre><p>A lazy-view wrapper of an <a href="arrays.html#Base.AbstractVector"><code>AbstractVector</code></a>, which turns a length-<code>n</code> vector into a <code>1×n</code> shaped row vector and represents the transpose of a vector (the elements are also transposed recursively). This type is usually constructed (and unwrapped) via the <a href="linalg.html#Base.transpose"><code>transpose</code></a> function or <code>.&#39;</code> operator (or related <a href="linalg.html#Base.adjoint"><code>adjoint</code></a> or <code>&#39;</code> operator).</p><p>By convention, a vector can be multiplied by a matrix on its left (<code>A * v</code>) whereas a row vector can be multiplied by a matrix on its right (such that <code>v.&#39; * A = (A.&#39; * v).&#39;</code>). It differs from a <code>1×n</code>-sized matrix by the facts that its transpose returns a vector and the inner product <code>v1.&#39; * v2</code> returns a scalar, but will otherwise behave similarly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; RowVector(a)
1×4 RowVector{Int64,Array{Int64,1}}:
 1  2  3  4

julia&gt; a.&#39;
1×4 RowVector{Int64,Array{Int64,1}}:
 1  2  3  4

julia&gt; a.&#39;[3]
3

julia&gt; a.&#39;[1,3]
3

julia&gt; a.&#39;[3,1]
ERROR: BoundsError: attempt to access 1×4 RowVector{Int64,Array{Int64,1}} at index [3, 1]
[...]

julia&gt; a.&#39;*a
30

julia&gt; B = [1 2; 3 4; 5 6; 7 8]
4×2 Array{Int64,2}:
 1  2
 3  4
 5  6
 7  8

julia&gt; a.&#39;*B
1×2 RowVector{Int64,Array{Int64,1}}:
 50  60</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/rowvector.jl#L3-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.ConjArray" href="#Base.LinAlg.ConjArray"><code>Base.LinAlg.ConjArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConjArray(array)</code></pre><p>A lazy-view wrapper of an <code>AbstractArray</code>, taking the elementwise complex conjugate. This type is usually constructed (and unwrapped) via the <a href="math.html#Base.conj"><code>conj</code></a> function (or related <a href="linalg.html#Base.adjoint"><code>adjoint</code></a>), but currently this is the default behavior for <code>RowVector</code> only. For other arrays, the <code>ConjArray</code> constructor can be used directly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; [1+im, 1-im]&#39;
1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:
 1-1im  1+1im

julia&gt; ConjArray([1+im 0; 0 1-im])
2×2 ConjArray{Complex{Int64},2,Array{Complex{Int64},2}}:
 1-1im  0+0im
 0+0im  1+1im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/conjarray.jl#L3-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.transpose" href="#Base.transpose"><code>Base.transpose</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">transpose(A::AbstractMatrix)</code></pre><p>The transposition operator (<code>.&#39;</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; transpose(A)
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/transpose.jl#L147-L166">source</a><div><pre><code class="language-none">transpose(v::AbstractVector)</code></pre><p>The transposition operator (<code>.&#39;</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; transpose(v)
1×3 RowVector{Int64,Array{Int64,1}}:
 1  2  3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/rowvector.jl#L103-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.transpose!" href="#Base.LinAlg.transpose!"><code>Base.LinAlg.transpose!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">transpose!(dest,src)</code></pre><p>Transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; transpose!(B, A);

julia&gt; B
2×2 Array{Complex{Int64},2}:
 3+2im  8+7im
 9+2im  4+6im

julia&gt; A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/transpose.jl#L8-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">adjoint(A)</code></pre><p>The conjugate transposition operator (<code>&#39;</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A =  [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; adjoint(A)
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L744-L761">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.adjoint!" href="#Base.LinAlg.adjoint!"><code>Base.LinAlg.adjoint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">adjoint!(dest,src)</code></pre><p>Conjugate transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; adjoint!(B, A);

julia&gt; B
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im

julia&gt; A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/transpose.jl#L43-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.peakflops" href="#Base.LinAlg.peakflops"><code>Base.LinAlg.peakflops</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">peakflops(n::Integer=2000; parallel::Bool=false)</code></pre><p><code>peakflops</code> computes the peak flop rate of the computer by using double precision <a href="linalg.html#Base.LinAlg.BLAS.gemm!"><code>gemm!</code></a>. By default, if no arguments are specified, it multiplies a matrix of size <code>n x n</code>, where <code>n = 2000</code>. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with <a href="linalg.html#Base.LinAlg.BLAS.set_num_threads"><code>BLAS.set_num_threads(n)</code></a>.</p><p>If the keyword argument <code>parallel</code> is set to <code>true</code>, <code>peakflops</code> is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument <code>n</code> still refers to the size of the problem that is solved on each processor.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/generic.jl#L1192-L1205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.stride1" href="#Base.LinAlg.stride1"><code>Base.LinAlg.stride1</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stride1(A) -&gt; Int</code></pre><p>Return the distance between successive array elements in dimension 1 in units of element size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; Base.LinAlg.stride1(A)
1

julia&gt; B = view(A, 2:2:4)
2-element view(::Array{Int64,1}, 2:2:4) with eltype Int64:
 2
 4

julia&gt; Base.LinAlg.stride1(B)
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/dense.jl#L115-L141">source</a></section><h2><a class="nav-anchor" id="Low-level-matrix-operations-1" href="#Low-level-matrix-operations-1">Low-level matrix operations</a></h2><p>Matrix operations involving transpositions operations like <code>A&#39; \ B</code> are converted by the Julia parser into calls to specially named functions like <a href="linalg.html#Base.Ac_ldiv_B"><code>Ac_ldiv_B</code></a>. If you want to overload these operations for your own types, then it is useful to know the names of these functions.</p><p>Also, in many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix.  This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with <code>!</code> below (e.g. <a href="linalg.html#Base.LinAlg.A_mul_B!"><code>A_mul_B!</code></a>) according to the usual Julia convention.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.A_ldiv_B!" href="#Base.LinAlg.A_ldiv_B!"><code>Base.LinAlg.A_ldiv_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_ldiv_B!([Y,] A, B) -&gt; Y</code></pre><p>Compute <code>A \ B</code> in-place and store the result in <code>Y</code>, returning the result. If only two arguments are passed, then <code>A_ldiv_B!(A, B)</code> overwrites <code>B</code> with the result.</p><p>The argument <code>A</code> should <em>not</em> be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="linalg.html#Base.LinAlg.factorize"><code>factorize</code></a> or <a href="linalg.html#Base.LinAlg.cholfact"><code>cholfact</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="linalg.html#Base.LinAlg.lufact!"><code>lufact!</code></a>), and performance-critical situations requiring <code>A_ldiv_B!</code> usually also require fine-grained control over the factorization of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/factorization.jl#L86-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_ldiv_Bc" href="#Base.A_ldiv_Bc"><code>Base.A_ldiv_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_ldiv_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A$</span> \ <span>$Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L860-L864">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_ldiv_Bt" href="#Base.A_ldiv_Bt"><code>Base.A_ldiv_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_ldiv_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A$</span> \ <span>$Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L881-L885">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.A_mul_B!" href="#Base.LinAlg.A_mul_B!"><code>Base.LinAlg.A_mul_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_mul_B!(Y, A, B) -&gt; Y</code></pre><p>Calculates the matrix-matrix or matrix-vector product <span>$AB$</span> and stores the result in <code>Y</code>, overwriting the existing value of <code>Y</code>. Note that <code>Y</code> must not be aliased with either <code>A</code> or <code>B</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); A_mul_B!(Y, A, B);

julia&gt; Y
2×2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/matmul.jl#L159-L175">source</a><div><pre><code class="language-none">A_mul_B!(A, B)</code></pre><p>Calculate the matrix-matrix product <span>$AB$</span>, overwriting one of <code>A</code> or <code>B</code> (but not both), and return the result (the overwritten argument).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/matmul.jl#L178-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_mul_Bc" href="#Base.A_mul_Bc"><code>Base.A_mul_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_mul_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A⋅Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L774-L778">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_mul_Bt" href="#Base.A_mul_Bt"><code>Base.A_mul_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_mul_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A⋅Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L795-L799">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_rdiv_Bc" href="#Base.A_rdiv_Bc"><code>Base.A_rdiv_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_rdiv_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A / Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L818-L822">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.A_rdiv_Bt" href="#Base.A_rdiv_Bt"><code>Base.A_rdiv_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_rdiv_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$A / Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L839-L843">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_ldiv_B" href="#Base.Ac_ldiv_B"><code>Base.Ac_ldiv_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_ldiv_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ$</span> \ <span>$B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L853-L857">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.Ac_ldiv_B!" href="#Base.LinAlg.Ac_ldiv_B!"><code>Base.LinAlg.Ac_ldiv_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_ldiv_B!([Y,] A, B) -&gt; Y</code></pre><p>Similar to <a href="linalg.html#Base.LinAlg.A_ldiv_B!"><code>A_ldiv_B!</code></a>, but return <span>$Aᴴ$</span> \ <span>$B$</span>, computing the result in-place in <code>Y</code> (or overwriting <code>B</code> if <code>Y</code> is not supplied).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/factorization.jl#L102-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_ldiv_Bc" href="#Base.Ac_ldiv_Bc"><code>Base.Ac_ldiv_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_ldiv_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ$</span> \ <span>$Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L867-L871">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_mul_B" href="#Base.Ac_mul_B"><code>Base.Ac_mul_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_mul_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ⋅B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L767-L771">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_mul_Bc" href="#Base.Ac_mul_Bc"><code>Base.Ac_mul_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_mul_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L781-L785">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_rdiv_B" href="#Base.Ac_rdiv_B"><code>Base.Ac_rdiv_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_rdiv_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ / B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L811-L815">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Ac_rdiv_Bc" href="#Base.Ac_rdiv_Bc"><code>Base.Ac_rdiv_Bc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Ac_rdiv_Bc(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᴴ / Bᴴ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L825-L829">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_ldiv_B" href="#Base.At_ldiv_B"><code>Base.At_ldiv_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_ldiv_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ$</span> \ <span>$B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L874-L878">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.At_ldiv_B!" href="#Base.LinAlg.At_ldiv_B!"><code>Base.LinAlg.At_ldiv_B!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_ldiv_B!([Y,] A, B) -&gt; Y</code></pre><p>Similar to <a href="linalg.html#Base.LinAlg.A_ldiv_B!"><code>A_ldiv_B!</code></a>, but return <span>$Aᵀ$</span> \ <span>$B$</span>, computing the result in-place in <code>Y</code> (or overwriting <code>B</code> if <code>Y</code> is not supplied).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/factorization.jl#L110-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_ldiv_Bt" href="#Base.At_ldiv_Bt"><code>Base.At_ldiv_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_ldiv_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ$</span> \ <span>$Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L888-L892">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_mul_B" href="#Base.At_mul_B"><code>Base.At_mul_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_mul_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ⋅B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L788-L792">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_mul_Bt" href="#Base.At_mul_Bt"><code>Base.At_mul_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_mul_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ⋅Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L802-L806">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_rdiv_B" href="#Base.At_rdiv_B"><code>Base.At_rdiv_B</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_rdiv_B(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ / B$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L832-L836">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.At_rdiv_Bt" href="#Base.At_rdiv_Bt"><code>Base.At_rdiv_Bt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">At_rdiv_Bt(A, B)</code></pre><p>For matrices or vectors <span>$A$</span> and <span>$B$</span>, calculates <span>$Aᵀ / Bᵀ$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/operators.jl#L846-L850">source</a></section><h2><a class="nav-anchor" id="BLAS-Functions-1" href="#BLAS-Functions-1">BLAS Functions</a></h2><p>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the <a href="http://www.netlib.org/lapack/">LAPACK library</a>, which in turn is built on top of basic linear-algebra building-blocks known as the <a href="http://www.netlib.org/blas/">BLAS</a>. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</p><p><code>Base.LinAlg.BLAS</code> provides wrappers for some of the BLAS functions. Those BLAS functions that overwrite one of the input arrays have names ending in <code>&#39;!&#39;</code>.  Usually, a BLAS function has four methods defined, for <a href="numbers.html#Core.Float64"><code>Float64</code></a>, <a href="numbers.html#Core.Float32"><code>Float32</code></a>, <code>Complex128</code>, and <code>Complex64</code> arrays.</p><h3><a class="nav-anchor" id="stdlib-blas-chars-1" href="#stdlib-blas-chars-1">BLAS Character Arguments</a></h3><p>Many BLAS functions accept arguments that determine whether to transpose an argument (<code>trans</code>), which triangle of a matrix to reference (<code>uplo</code> or <code>ul</code>), whether the diagonal of a triangular matrix can be assumed to be all ones (<code>dA</code>) or which side of a matrix multiplication the input argument belongs on (<code>side</code>). The possiblities are:</p><h4><a class="nav-anchor" id="stdlib-blas-side-1" href="#stdlib-blas-side-1">Multplication Order</a></h4><table><tr><th><code>side</code></th><th>Meaning</th></tr><tr><td><code>&#39;L&#39;</code></td><td>The argument goes on the <em>left</em> side of a matrix-matrix operation.</td></tr><tr><td><code>&#39;R&#39;</code></td><td>The argument goes on the <em>right</em> side of a matrix-matrix operation.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-uplo-1" href="#stdlib-blas-uplo-1">Triangle Referencing</a></h4><table><tr><th><code>uplo</code>/<code>ul</code></th><th>Meaning</th></tr><tr><td><code>&#39;U&#39;</code></td><td>Only the <em>upper</em> triangle of the matrix will be used.</td></tr><tr><td><code>&#39;L&#39;</code></td><td>Only the <em>lower</em> triangle of the matrix will be used.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-trans-1" href="#stdlib-blas-trans-1">Transposition Operation</a></h4><table><tr><th><code>trans</code>/<code>tX</code></th><th>Meaning</th></tr><tr><td><code>&#39;N&#39;</code></td><td>The input matrix <code>X</code> is not transposed or conjugated.</td></tr><tr><td><code>&#39;T&#39;</code></td><td>The input matrix <code>X</code> will be transposed.</td></tr><tr><td><code>&#39;C&#39;</code></td><td>The input matrix <code>X</code> will be conjugated and transposed.</td></tr></table><h4><a class="nav-anchor" id="stdlib-blas-diag-1" href="#stdlib-blas-diag-1">Unit Diagonal</a></h4><table><tr><th><code>diag</code>/<code>dX</code></th><th>Meaning</th></tr><tr><td><code>&#39;N&#39;</code></td><td>The diagonal values of the matrix <code>X</code> will be read.</td></tr><tr><td><code>&#39;U&#39;</code></td><td>The diagonal of the matrix <code>X</code> is assumed to be all ones.</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.dotu" href="#Base.LinAlg.BLAS.dotu"><code>Base.LinAlg.BLAS.dotu</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dotu(n, X, incx, Y, incy)</code></pre><p>Dot function for two complex vectors consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>Y</code> with stride <code>incy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Base.BLAS.dotu(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)
-10.0 + 10.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L250-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.dotc" href="#Base.LinAlg.BLAS.dotc"><code>Base.LinAlg.BLAS.dotc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dotc(n, X, incx, U, incy)</code></pre><p>Dot function for two complex vectors, consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code> and <code>n</code> elements of array <code>U</code> with stride <code>incy</code>, conjugating the first vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Base.BLAS.dotc(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)
10.0 - 10.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L235-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.blascopy!" href="#Base.LinAlg.BLAS.blascopy!"><code>Base.LinAlg.BLAS.blascopy!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">blascopy!(n, X, incx, Y, incy)</code></pre><p>Copy <code>n</code> elements of array <code>X</code> with stride <code>incx</code> to array <code>Y</code> with stride <code>incy</code>. Returns <code>Y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L165-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.nrm2" href="#Base.LinAlg.BLAS.nrm2"><code>Base.LinAlg.BLAS.nrm2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nrm2(n, X, incx)</code></pre><p>2-norm of a vector consisting of <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Base.BLAS.nrm2(4, ones(8), 2)
2.0

julia&gt; Base.BLAS.nrm2(1, ones(8), 2)
1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L343-L356">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.asum" href="#Base.LinAlg.BLAS.asum"><code>Base.LinAlg.BLAS.asum</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asum(n, X, incx)</code></pre><p>Sum of the absolute values of the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Base.BLAS.asum(5, im*ones(10), 2)
5.0

julia&gt; Base.BLAS.asum(2, im*ones(10), 5)
2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L376-L389">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.axpy!" href="#Base.LinAlg.axpy!"><code>Base.LinAlg.axpy!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">axpy!(a, X, Y)</code></pre><p>Overwrite <code>Y</code> with <code>a*X + Y</code>, where <code>a</code> is a scalar. Return <code>Y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1; 2; 3];

julia&gt; y = [4; 5; 6];

julia&gt; Base.BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L409-L426">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.scal!" href="#Base.LinAlg.BLAS.scal!"><code>Base.LinAlg.BLAS.scal!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">scal!(n, a, X, incx)</code></pre><p>Overwrite <code>X</code> with <code>a*X</code> for the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>. Returns <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L189-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.scal" href="#Base.LinAlg.BLAS.scal"><code>Base.LinAlg.BLAS.scal</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">scal(n, a, X, incx)</code></pre><p>Return <code>X</code> scaled by <code>a</code> for the first <code>n</code> elements of array <code>X</code> with stride <code>incx</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L196-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.ger!" href="#Base.LinAlg.BLAS.ger!"><code>Base.LinAlg.BLAS.ger!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ger!(alpha, x, y, A)</code></pre><p>Rank-1 update of the matrix <code>A</code> with vectors <code>x</code> and <code>y</code> as <code>alpha*x*y&#39; + A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L961-L965">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.syr!" href="#Base.LinAlg.BLAS.syr!"><code>Base.LinAlg.BLAS.syr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syr!(uplo, alpha, x, A)</code></pre><p>Rank-1 update of the symmetric matrix <code>A</code> with vector <code>x</code> as <code>alpha*x*x.&#39; + A</code>. <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a> controls which triangle of <code>A</code> is updated. Returns <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L992-L997">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.syrk!" href="#Base.LinAlg.BLAS.syrk!"><code>Base.LinAlg.BLAS.syrk!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syrk!(uplo, trans, alpha, A, beta, C)</code></pre><p>Rank-k update of the symmetric matrix <code>C</code> as <code>alpha*A*A.&#39; + beta*C</code> or <code>alpha*A.&#39;*A + beta*C</code> according to <a href="linalg.html#stdlib-blas-trans-1"><code>trans</code></a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>C</code> is used. Returns <code>C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1226-L1232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.syrk" href="#Base.LinAlg.BLAS.syrk"><code>Base.LinAlg.BLAS.syrk</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syrk(uplo, trans, alpha, A)</code></pre><p>Returns either the upper triangle or the lower triangle of <code>A</code>, according to <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a>, of <code>alpha*A*A.&#39;</code> or <code>alpha*A.&#39;*A</code>, according to <a href="linalg.html#stdlib-blas-trans-1"><code>trans</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1235-L1242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.her!" href="#Base.LinAlg.BLAS.her!"><code>Base.LinAlg.BLAS.her!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">her!(uplo, alpha, x, A)</code></pre><p>Methods for complex arrays only. Rank-1 update of the Hermitian matrix <code>A</code> with vector <code>x</code> as <code>alpha*x*x&#39; + A</code>. <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a> controls which triangle of <code>A</code> is updated. Returns <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1022-L1028">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.herk!" href="#Base.LinAlg.BLAS.herk!"><code>Base.LinAlg.BLAS.herk!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">herk!(uplo, trans, alpha, A, beta, C)</code></pre><p>Methods for complex arrays only. Rank-k update of the Hermitian matrix <code>C</code> as <code>alpha*A*A&#39; + beta*C</code> or <code>alpha*A&#39;*A + beta*C</code> according to <a href="linalg.html#stdlib-blas-trans-1"><code>trans</code></a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>C</code> is updated. Returns <code>C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1282-L1289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.herk" href="#Base.LinAlg.BLAS.herk"><code>Base.LinAlg.BLAS.herk</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">herk(uplo, trans, alpha, A)</code></pre><p>Methods for complex arrays only. Returns the <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>alpha*A*A&#39;</code> or <code>alpha*A&#39;*A</code>, according to <a href="linalg.html#stdlib-blas-trans-1"><code>trans</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1292-L1298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gbmv!" href="#Base.LinAlg.BLAS.gbmv!"><code>Base.LinAlg.BLAS.gbmv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)</code></pre><p>Update vector <code>y</code> as <code>alpha*A*x + beta*y</code> or <code>alpha*A&#39;*x + beta*y</code> according to <a href="linalg.html#stdlib-blas-trans-1"><code>trans</code></a>. The matrix <code>A</code> is a general band matrix of dimension <code>m</code> by <code>size(A,2)</code> with <code>kl</code> sub-diagonals and <code>ku</code> super-diagonals. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L604-L610">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gbmv" href="#Base.LinAlg.BLAS.gbmv"><code>Base.LinAlg.BLAS.gbmv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gbmv(trans, m, kl, ku, alpha, A, x)</code></pre><p>Return <code>alpha*A*x</code> or <code>alpha*A&#39;*x</code> according to <a href="linalg.html#stdlib-blas-trans-1"><code>trans</code></a>. The matrix <code>A</code> is a general band matrix of dimension <code>m</code> by <code>size(A,2)</code> with <code>kl</code> sub-diagonals and <code>ku</code> super-diagonals, and <code>alpha</code> is a scalar.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L613-L619">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.sbmv!" href="#Base.LinAlg.BLAS.sbmv!"><code>Base.LinAlg.BLAS.sbmv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sbmv!(uplo, k, alpha, A, x, beta, y)</code></pre><p>Update vector <code>y</code> as <code>alpha*A*x + beta*y</code> where <code>A</code> is a a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. The storage layout for <code>A</code> is described the reference BLAS module, level-2 BLAS at <a href="http://www.netlib.org/lapack/explore-html/">http://www.netlib.org/lapack/explore-html/</a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p><p>Return the updated <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L811-L821">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.sbmv-NTuple{5,Any}" href="#Base.LinAlg.BLAS.sbmv-NTuple{5,Any}"><code>Base.LinAlg.BLAS.sbmv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sbmv(uplo, k, alpha, A, x)</code></pre><p>Return <code>alpha*A*x</code> where <code>A</code> is a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L793-L799">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.sbmv-NTuple{4,Any}" href="#Base.LinAlg.BLAS.sbmv-NTuple{4,Any}"><code>Base.LinAlg.BLAS.sbmv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sbmv(uplo, k, A, x)</code></pre><p>Return <code>A*x</code> where <code>A</code> is a symmetric band matrix of order <code>size(A,2)</code> with <code>k</code> super-diagonals stored in the argument <code>A</code>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>uplo</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L802-L808">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemm!" href="#Base.LinAlg.BLAS.gemm!"><code>Base.LinAlg.BLAS.gemm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gemm!(tA, tB, alpha, A, B, beta, C)</code></pre><p>Update <code>C</code> as <code>alpha*A*B + beta*C</code> or the other three variants according to <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>. Return the updated <code>C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1052-L1057">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemm-NTuple{5,Any}" href="#Base.LinAlg.BLAS.gemm-NTuple{5,Any}"><code>Base.LinAlg.BLAS.gemm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gemm(tA, tB, alpha, A, B)</code></pre><p>Return <code>alpha*A*B</code> or the other three variants according to <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1104-L1108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemm-NTuple{4,Any}" href="#Base.LinAlg.BLAS.gemm-NTuple{4,Any}"><code>Base.LinAlg.BLAS.gemm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gemm(tA, tB, A, B)</code></pre><p>Return <code>A*B</code> or the other three variants according to <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a> and <code>tB</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1111-L1115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemv!" href="#Base.LinAlg.BLAS.gemv!"><code>Base.LinAlg.BLAS.gemv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gemv!(tA, alpha, A, x, beta, y)</code></pre><p>Update the vector <code>y</code> as <code>alpha*A*x + beta*y</code> or <code>alpha*A&#39;x + beta*y</code> according to <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L578-L584">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemv-NTuple{4,Any}" href="#Base.LinAlg.BLAS.gemv-NTuple{4,Any}"><code>Base.LinAlg.BLAS.gemv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gemv(tA, alpha, A, x)</code></pre><p>Return <code>alpha*A*x</code> or <code>alpha*A&#39;x</code> according to <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>. <code>alpha</code> is a scalar.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L587-L592">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.gemv-Tuple{Any,Any,Any}" href="#Base.LinAlg.BLAS.gemv-Tuple{Any,Any,Any}"><code>Base.LinAlg.BLAS.gemv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gemv(tA, A, x)</code></pre><p>Return <code>A*x</code> or <code>A&#39;x</code> according to <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L595-L599">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symm!" href="#Base.LinAlg.BLAS.symm!"><code>Base.LinAlg.BLAS.symm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">symm!(side, ul, alpha, A, B, beta, C)</code></pre><p>Update <code>C</code> as <code>alpha*A*B + beta*C</code> or <code>alpha*B*A + beta*C</code> according to <a href="linalg.html#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. Return the updated <code>C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1177-L1183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symm-NTuple{5,Any}" href="#Base.LinAlg.BLAS.symm-NTuple{5,Any}"><code>Base.LinAlg.BLAS.symm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symm(side, ul, alpha, A, B)</code></pre><p>Return <code>alpha*A*B</code> or <code>alpha*B*A</code> according to <a href="linalg.html#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1159-L1165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symm-NTuple{4,Any}" href="#Base.LinAlg.BLAS.symm-NTuple{4,Any}"><code>Base.LinAlg.BLAS.symm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symm(side, ul, A, B)</code></pre><p>Return <code>A*B</code> or <code>B*A</code> according to <a href="linalg.html#stdlib-blas-side-1"><code>side</code></a>. <code>A</code> is assumed to be symmetric. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1168-L1174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symv!" href="#Base.LinAlg.BLAS.symv!"><code>Base.LinAlg.BLAS.symv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">symv!(ul, alpha, A, x, beta, y)</code></pre><p>Update the vector <code>y</code> as <code>alpha*A*x + beta*y</code>. <code>A</code> is assumed to be symmetric. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <code>alpha</code> and <code>beta</code> are scalars. Return the updated <code>y</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L658-L664">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symv-NTuple{4,Any}" href="#Base.LinAlg.BLAS.symv-NTuple{4,Any}"><code>Base.LinAlg.BLAS.symv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symv(ul, alpha, A, x)</code></pre><p>Return <code>alpha*A*x</code>. <code>A</code> is assumed to be symmetric. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <code>alpha</code> is a scalar.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L709-L715">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.symv-Tuple{Any,Any,Any}" href="#Base.LinAlg.BLAS.symv-Tuple{Any,Any,Any}"><code>Base.LinAlg.BLAS.symv</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symv(ul, A, x)</code></pre><p>Return <code>A*x</code>. <code>A</code> is assumed to be symmetric. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L718-L723">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trmm!" href="#Base.LinAlg.BLAS.trmm!"><code>Base.LinAlg.BLAS.trmm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trmm!(side, ul, tA, dA, alpha, A, B)</code></pre><p>Update <code>B</code> as <code>alpha*A*B</code> or one of the other three variants determined by <a href="linalg.html#stdlib-blas-side-1"><code>side</code></a> and <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="linalg.html#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>B</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1415-L1424">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trmm" href="#Base.LinAlg.BLAS.trmm"><code>Base.LinAlg.BLAS.trmm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trmm(side, ul, tA, dA, alpha, A, B)</code></pre><p>Returns <code>alpha*A*B</code> or one of the other three variants determined by <a href="linalg.html#stdlib-blas-side-1"><code>side</code></a> and <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="linalg.html#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1427-L1435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trsm!" href="#Base.LinAlg.BLAS.trsm!"><code>Base.LinAlg.BLAS.trsm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsm!(side, ul, tA, dA, alpha, A, B)</code></pre><p>Overwrite <code>B</code> with the solution to <code>A*X = alpha*B</code> or one of the other three variants determined by <a href="linalg.html#stdlib-blas-side-1"><code>side</code></a> and <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="linalg.html#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Returns the updated <code>B</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1438-L1447">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trsm" href="#Base.LinAlg.BLAS.trsm"><code>Base.LinAlg.BLAS.trsm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsm(side, ul, tA, dA, alpha, A, B)</code></pre><p>Return the solution to <code>A*X = alpha*B</code> or one of the other three variants determined by determined by <a href="linalg.html#stdlib-blas-side-1"><code>side</code></a> and <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="linalg.html#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L1450-L1458">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trmv!" href="#Base.LinAlg.BLAS.trmv!"><code>Base.LinAlg.BLAS.trmv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trmv!(ul, tA, dA, A, b)</code></pre><p>Return <code>op(A)*b</code>, where <code>op</code> is determined by <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="linalg.html#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on <code>b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L867-L875">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trmv" href="#Base.LinAlg.BLAS.trmv"><code>Base.LinAlg.BLAS.trmv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trmv(ul, tA, dA, A, b)</code></pre><p>Return <code>op(A)*b</code>, where <code>op</code> is determined by <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a>. Only the <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a> triangle of <code>A</code> is used. <a href="linalg.html#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L857-L864">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trsv!" href="#Base.LinAlg.BLAS.trsv!"><code>Base.LinAlg.BLAS.trsv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsv!(ul, tA, dA, A, b)</code></pre><p>Overwrite <code>b</code> with the solution to <code>A*x = b</code> or one of the other two variants determined by <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a> and <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a>. <a href="linalg.html#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones. Return the updated <code>b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L909-L917">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.trsv" href="#Base.LinAlg.BLAS.trsv"><code>Base.LinAlg.BLAS.trsv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsv(ul, tA, dA, A, b)</code></pre><p>Return the solution to <code>A*x = b</code> or one of the other two variants determined by <a href="linalg.html#stdlib-blas-trans-1"><code>tA</code></a> and <a href="linalg.html#stdlib-blas-uplo-1"><code>ul</code></a>. <a href="linalg.html#stdlib-blas-diag-1"><code>dA</code></a> determines if the diagonal values are read or are assumed to be all ones.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L920-L927">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.BLAS.set_num_threads" href="#Base.LinAlg.BLAS.set_num_threads"><code>Base.LinAlg.BLAS.set_num_threads</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">set_num_threads(n)</code></pre><p>Set the number of threads the BLAS library should use.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/blas.jl#L97-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.I" href="#Base.LinAlg.I"><code>Base.LinAlg.I</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">I</code></pre><p>An object of type <a href="linalg.html#Base.LinAlg.UniformScaling"><code>UniformScaling</code></a>, representing an identity matrix of any size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ones(5, 6) * I == ones(5, 6)
true

julia&gt; [1 2im 3; 1im 2 3] * I
2×3 Array{Complex{Int64},2}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/uniformscaling.jl#L34-L49">source</a></section><h2><a class="nav-anchor" id="LAPACK-Functions-1" href="#LAPACK-Functions-1">LAPACK Functions</a></h2><p><code>Base.LinAlg.LAPACK</code> provides wrappers for some of the LAPACK functions for linear algebra.  Those functions that overwrite one of the input arrays have names ending in <code>&#39;!&#39;</code>.</p><p>Usually a function has 4 methods defined, one each for <a href="numbers.html#Core.Float64"><code>Float64</code></a>, <a href="numbers.html#Core.Float32"><code>Float32</code></a>, <code>Complex128</code> and <code>Complex64</code> arrays.</p><p>Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing, there is no commitment to support/deprecate this specific set of functions in future releases.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gbtrf!" href="#Base.LinAlg.LAPACK.gbtrf!"><code>Base.LinAlg.LAPACK.gbtrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gbtrf!(kl, ku, m, AB) -&gt; (AB, ipiv)</code></pre><p>Compute the LU factorization of a banded matrix <code>AB</code>. <code>kl</code> is the first subdiagonal containing a nonzero band, <code>ku</code> is the last superdiagonal containing one, and <code>m</code> is the first dimension of the matrix <code>AB</code>. Returns the LU factorization in-place and <code>ipiv</code>, the vector of pivots used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L163-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gbtrs!" href="#Base.LinAlg.LAPACK.gbtrs!"><code>Base.LinAlg.LAPACK.gbtrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gbtrs!(trans, kl, ku, m, AB, ipiv, B)</code></pre><p>Solve the equation <code>AB * X = B</code>. <code>trans</code> determines the orientation of <code>AB</code>. It may be <code>N</code> (no transpose), <code>T</code> (transpose), or <code>C</code> (conjugate transpose). <code>kl</code> is the first subdiagonal containing a nonzero band, <code>ku</code> is the last superdiagonal containing one, and <code>m</code> is the first dimension of the matrix <code>AB</code>. <code>ipiv</code> is the vector of pivots returned from <code>gbtrf!</code>. Returns the vector or matrix <code>X</code>, overwriting <code>B</code> in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L173-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gebal!" href="#Base.LinAlg.LAPACK.gebal!"><code>Base.LinAlg.LAPACK.gebal!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gebal!(job, A) -&gt; (ilo, ihi, scale)</code></pre><p>Balance the matrix <code>A</code> before computing its eigensystem or Schur factorization. <code>job</code> can be one of <code>N</code> (<code>A</code> will not be permuted or scaled), <code>P</code> (<code>A</code> will only be permuted), <code>S</code> (<code>A</code> will only be scaled), or <code>B</code> (<code>A</code> will be both permuted and scaled). Modifies <code>A</code> in-place and returns <code>ilo</code>, <code>ihi</code>, and <code>scale</code>. If permuting was turned on, <code>A[i,j] = 0</code> if <code>j &gt; i</code> and <code>1 &lt; j &lt; ilo</code> or <code>j &gt; ihi</code>. <code>scale</code> contains information about the scaling/permutations performed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L237-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gebak!" href="#Base.LinAlg.LAPACK.gebak!"><code>Base.LinAlg.LAPACK.gebak!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gebak!(job, side, ilo, ihi, scale, V)</code></pre><p>Transform the eigenvectors <code>V</code> of a matrix balanced using <code>gebal!</code> to the unscaled/unpermuted eigenvectors of the original matrix. Modifies <code>V</code> in-place. <code>side</code> can be <code>L</code> (left eigenvectors are transformed) or <code>R</code> (right eigenvectors are transformed).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L249-L256">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gebrd!" href="#Base.LinAlg.LAPACK.gebrd!"><code>Base.LinAlg.LAPACK.gebrd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gebrd!(A) -&gt; (A, d, e, tauq, taup)</code></pre><p>Reduce <code>A</code> in-place to bidiagonal form <code>A = QBP&#39;</code>. Returns <code>A</code>, containing the bidiagonal matrix <code>B</code>; <code>d</code>, containing the diagonal elements of <code>B</code>; <code>e</code>, containing the off-diagonal elements of <code>B</code>; <code>tauq</code>, containing the elementary reflectors representing <code>Q</code>; and <code>taup</code>, containing the elementary reflectors representing <code>P</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L546-L554">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gelqf!" href="#Base.LinAlg.LAPACK.gelqf!"><code>Base.LinAlg.LAPACK.gelqf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gelqf!(A, tau)</code></pre><p>Compute the <code>LQ</code> factorization of <code>A</code>, <code>A = LQ</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L557-L566">source</a><div><pre><code class="language-none">gelqf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>LQ</code> factorization of <code>A</code>, <code>A = LQ</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L652-L659">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqlf!" href="#Base.LinAlg.LAPACK.geqlf!"><code>Base.LinAlg.LAPACK.geqlf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqlf!(A, tau)</code></pre><p>Compute the <code>QL</code> factorization of <code>A</code>, <code>A = QL</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L569-L577">source</a><div><pre><code class="language-none">geqlf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>QL</code> factorization of <code>A</code>, <code>A = QL</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L662-L669">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqrf!" href="#Base.LinAlg.LAPACK.geqrf!"><code>Base.LinAlg.LAPACK.geqrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqrf!(A, tau)</code></pre><p>Compute the <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L619-L627">source</a><div><pre><code class="language-none">geqrf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L694-L701">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqp3!" href="#Base.LinAlg.LAPACK.geqp3!"><code>Base.LinAlg.LAPACK.geqp3!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqp3!(A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3. <code>P</code> is a pivoting matrix, represented by <code>jpvt</code>. <code>tau</code> stores the elementary reflectors. <code>jpvt</code> must have length length greater than or equal to <code>n</code> if <code>A</code> is an <code>(m x n)</code> matrix. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p><code>A</code>, <code>jpvt</code>, and <code>tau</code> are modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L580-L590">source</a><div><pre><code class="language-none">geqp3!(A, jpvt) -&gt; (A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3. <code>P</code> is a pivoting matrix, represented by <code>jpvt</code>. <code>jpvt</code> must have length greater than or equal to <code>n</code> if <code>A</code> is an <code>(m x n)</code> matrix.</p><p>Returns <code>A</code> and <code>jpvt</code>, modified in-place, and <code>tau</code>, which stores the elementary reflectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L714-L723">source</a><div><pre><code class="language-none">geqp3!(A) -&gt; (A, jpvt, tau)</code></pre><p>Compute the pivoted <code>QR</code> factorization of <code>A</code>, <code>AP = QR</code> using BLAS level 3.</p><p>Returns <code>A</code>, modified in-place, <code>jpvt</code>, which represents the pivoting matrix <code>P</code>, and <code>tau</code>, which stores the elementary reflectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L729-L736">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gerqf!" href="#Base.LinAlg.LAPACK.gerqf!"><code>Base.LinAlg.LAPACK.gerqf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gerqf!(A, tau)</code></pre><p>Compute the <code>RQ</code> factorization of <code>A</code>, <code>A = RQ</code>. <code>tau</code> contains scalars which parameterize the elementary reflectors of the factorization. <code>tau</code> must have length greater than or equal to the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>tau</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L630-L638">source</a><div><pre><code class="language-none">gerqf!(A) -&gt; (A, tau)</code></pre><p>Compute the <code>RQ</code> factorization of <code>A</code>, <code>A = RQ</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>tau</code>, which contains scalars which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L704-L711">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqrt!" href="#Base.LinAlg.LAPACK.geqrt!"><code>Base.LinAlg.LAPACK.geqrt!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqrt!(A, T)</code></pre><p>Compute the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>T</code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of <code>T</code> sets the block size and it must be between 1 and <code>n</code>. The second dimension of <code>T</code> must equal the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>T</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L593-L603">source</a><div><pre><code class="language-none">geqrt!(A, nb) -&gt; (A, T)</code></pre><p>Compute the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>nb</code> sets the block size and it must be between 1 and <code>n</code>, the second dimension of <code>A</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>T</code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L672-L681">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geqrt3!" href="#Base.LinAlg.LAPACK.geqrt3!"><code>Base.LinAlg.LAPACK.geqrt3!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geqrt3!(A, T)</code></pre><p>Recursively computes the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>. <code>T</code> contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of <code>T</code> sets the block size and it must be between 1 and <code>n</code>. The second dimension of <code>T</code> must equal the smallest dimension of <code>A</code>.</p><p>Returns <code>A</code> and <code>T</code> modified in-place.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L606-L616">source</a><div><pre><code class="language-none">geqrt3!(A) -&gt; (A, T)</code></pre><p>Recursively computes the blocked <code>QR</code> factorization of <code>A</code>, <code>A = QR</code>.</p><p>Returns <code>A</code>, modified in-place, and <code>T</code>, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L684-L691">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.getrf!" href="#Base.LinAlg.LAPACK.getrf!"><code>Base.LinAlg.LAPACK.getrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getrf!(A) -&gt; (A, ipiv, info)</code></pre><p>Compute the pivoted <code>LU</code> factorization of <code>A</code>, <code>A = LU</code>.</p><p>Returns <code>A</code>, modified in-place, <code>ipiv</code>, the pivoting information, and an <code>info</code> code which indicates success (<code>info = 0</code>), a singular value in <code>U</code> (<code>info = i</code>, in which case <code>U[i,i]</code> is singular), or an error code (<code>info &lt; 0</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L641-L649">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.tzrzf!" href="#Base.LinAlg.LAPACK.tzrzf!"><code>Base.LinAlg.LAPACK.tzrzf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tzrzf!(A) -&gt; (A, tau)</code></pre><p>Transforms the upper trapezoidal matrix <code>A</code> to upper triangular form in-place. Returns <code>A</code> and <code>tau</code>, the scalar parameters for the elementary reflectors of the transformation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L836-L842">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormrz!" href="#Base.LinAlg.LAPACK.ormrz!"><code>Base.LinAlg.LAPACK.ormrz!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormrz!(side, trans, A, tau, C)</code></pre><p>Multiplies the matrix <code>C</code> by <code>Q</code> from the transformation supplied by <code>tzrzf!</code>. Depending on <code>side</code> or <code>trans</code> the multiplication can be left-sided (<code>side = L, Q*C</code>) or right-sided (<code>side = R, C*Q</code>) and <code>Q</code> can be unmodified (<code>trans = N</code>), transposed (<code>trans = T</code>), or conjugate transposed (<code>trans = C</code>). Returns matrix <code>C</code> which is modified in-place with the result of the multiplication.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L824-L833">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gels!" href="#Base.LinAlg.LAPACK.gels!"><code>Base.LinAlg.LAPACK.gels!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gels!(trans, A, B) -&gt; (F, B, ssr)</code></pre><p>Solves the linear equation <code>A * X = B</code>, <code>A.&#39; * X =B</code>, or <code>A&#39; * X = B</code> using a QR or LQ factorization. Modifies the matrix/vector <code>B</code> in place with the solution. <code>A</code> is overwritten with its <code>QR</code> or <code>LQ</code> factorization. <code>trans</code> may be one of <code>N</code> (no modification), <code>T</code> (transpose), or <code>C</code> (conjugate transpose). <code>gels!</code> searches for the minimum norm/least squares solution. <code>A</code> may be under or over determined. The solution is returned in <code>B</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L972-L981">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gesv!" href="#Base.LinAlg.LAPACK.gesv!"><code>Base.LinAlg.LAPACK.gesv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gesv!(A, B) -&gt; (B, A, ipiv)</code></pre><p>Solves the linear equation <code>A * X = B</code> where <code>A</code> is a square matrix using the <code>LU</code> factorization of <code>A</code>. <code>A</code> is overwritten with its <code>LU</code> factorization and <code>B</code> is overwritten with the solution <code>X</code>. <code>ipiv</code> contains the pivoting information for the <code>LU</code> factorization of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L984-L991">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.getrs!" href="#Base.LinAlg.LAPACK.getrs!"><code>Base.LinAlg.LAPACK.getrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getrs!(trans, A, ipiv, B)</code></pre><p>Solves the linear equation <code>A * X = B</code>, <code>A.&#39; * X =B</code>, or <code>A&#39; * X = B</code> for square <code>A</code>. Modifies the matrix/vector <code>B</code> in place with the solution. <code>A</code> is the <code>LU</code> factorization from <code>getrf!</code>, with <code>ipiv</code> the pivoting information. <code>trans</code> may be one of <code>N</code> (no modification), <code>T</code> (transpose), or <code>C</code> (conjugate transpose).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L994-L1002">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.getri!" href="#Base.LinAlg.LAPACK.getri!"><code>Base.LinAlg.LAPACK.getri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getri!(A, ipiv)</code></pre><p>Computes the inverse of <code>A</code>, using its <code>LU</code> factorization found by <code>getrf!</code>. <code>ipiv</code> is the pivot information output and <code>A</code> contains the <code>LU</code> factorization of <code>getrf!</code>. <code>A</code> is overwritten with its inverse.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1005-L1012">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gesvx!" href="#Base.LinAlg.LAPACK.gesvx!"><code>Base.LinAlg.LAPACK.gesvx!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -&gt; (X, equed, R, C, B, rcond, ferr, berr, work)</code></pre><p>Solves the linear equation <code>A * X = B</code> (<code>trans = N</code>), <code>A.&#39; * X =B</code> (<code>trans = T</code>), or <code>A&#39; * X = B</code> (<code>trans = C</code>) using the <code>LU</code> factorization of <code>A</code>. <code>fact</code> may be <code>E</code>, in which case <code>A</code> will be equilibrated and copied to <code>AF</code>; <code>F</code>, in which case <code>AF</code> and <code>ipiv</code> from a previous <code>LU</code> factorization are inputs; or <code>N</code>, in which case <code>A</code> will be copied to <code>AF</code> and then factored. If <code>fact = F</code>, <code>equed</code> may be <code>N</code>, meaning <code>A</code> has not been equilibrated; <code>R</code>, meaning <code>A</code> was multiplied by <code>Diagonal(R)</code> from the left; <code>C</code>, meaning <code>A</code> was multiplied by <code>Diagonal(C)</code> from the right; or <code>B</code>, meaning <code>A</code> was multiplied by <code>Diagonal(R)</code> from the left and <code>Diagonal(C)</code> from the right. If <code>fact = F</code> and <code>equed = R</code> or <code>B</code> the elements of <code>R</code> must all be positive. If <code>fact = F</code> and <code>equed = C</code> or <code>B</code> the elements of <code>C</code> must all be positive.</p><p>Returns the solution <code>X</code>; <code>equed</code>, which is an output if <code>fact</code> is not <code>N</code>, and describes the equilibration that was performed; <code>R</code>, the row equilibration diagonal; <code>C</code>, the column equilibration diagonal; <code>B</code>, which may be overwritten with its equilibrated form <code>Diagonal(R)*B</code> (if <code>trans = N</code> and <code>equed = R,B</code>) or <code>Diagonal(C)*B</code> (if <code>trans = T,C</code> and <code>equed = C,B</code>); <code>rcond</code>, the reciprocal condition number of <code>A</code> after equilbrating; <code>ferr</code>, the forward error bound for each solution vector in <code>X</code>; <code>berr</code>, the forward error bound for each solution vector in <code>X</code>; and <code>work</code>, the reciprocal pivot growth factor.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1155-L1178">source</a><div><pre><code class="language-none">gesvx!(A, B)</code></pre><p>The no-equilibration, no-transpose simplification of <code>gesvx!</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1182-L1186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gelsd!" href="#Base.LinAlg.LAPACK.gelsd!"><code>Base.LinAlg.LAPACK.gelsd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gelsd!(A, B, rcond) -&gt; (B, rnk)</code></pre><p>Computes the least norm solution of <code>A * X = B</code> by finding the <code>SVD</code> factorization of <code>A</code>, then dividing-and-conquering the problem. <code>B</code> is overwritten with the solution <code>X</code>. Singular values below <code>rcond</code> will be treated as zero. Returns the solution in <code>B</code> and the effective rank of <code>A</code> in <code>rnk</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1377-L1385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gelsy!" href="#Base.LinAlg.LAPACK.gelsy!"><code>Base.LinAlg.LAPACK.gelsy!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gelsy!(A, B, rcond) -&gt; (B, rnk)</code></pre><p>Computes the least norm solution of <code>A * X = B</code> by finding the full <code>QR</code> factorization of <code>A</code>, then dividing-and-conquering the problem. <code>B</code> is overwritten with the solution <code>X</code>. Singular values below <code>rcond</code> will be treated as zero. Returns the solution in <code>B</code> and the effective rank of <code>A</code> in <code>rnk</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1388-L1396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gglse!" href="#Base.LinAlg.LAPACK.gglse!"><code>Base.LinAlg.LAPACK.gglse!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gglse!(A, c, B, d) -&gt; (X,res)</code></pre><p>Solves the equation <code>A * x = c</code> where <code>x</code> is subject to the equality constraint <code>B * x = d</code>. Uses the formula <code>||c - A*x||^2 = 0</code> to solve. Returns <code>X</code> and the residual sum-of-squares.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1449-L1455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geev!" href="#Base.LinAlg.LAPACK.geev!"><code>Base.LinAlg.LAPACK.geev!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geev!(jobvl, jobvr, A) -&gt; (W, VL, VR)</code></pre><p>Finds the eigensystem of <code>A</code>. If <code>jobvl = N</code>, the left eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed. Returns the eigenvalues in <code>W</code>, the right eigenvectors in <code>VR</code>, and the left eigenvectors in <code>VL</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1743-L1751">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gesdd!" href="#Base.LinAlg.LAPACK.gesdd!"><code>Base.LinAlg.LAPACK.gesdd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gesdd!(job, A) -&gt; (U, S, VT)</code></pre><p>Finds the singular value decomposition of <code>A</code>, <code>A = U * S * V&#39;</code>, using a divide and conquer approach. If <code>job = A</code>, all the columns of <code>U</code> and the rows of <code>V&#39;</code> are computed. If <code>job = N</code>, no columns of <code>U</code> or rows of <code>V&#39;</code> are computed. If <code>job = O</code>, <code>A</code> is overwritten with the columns of (thin) <code>U</code> and the rows of (thin) <code>V&#39;</code>. If <code>job = S</code>, the columns of (thin) <code>U</code> and the rows of (thin) <code>V&#39;</code> are computed and returned separately.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1754-L1763">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gesvd!" href="#Base.LinAlg.LAPACK.gesvd!"><code>Base.LinAlg.LAPACK.gesvd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gesvd!(jobu, jobvt, A) -&gt; (U, S, VT)</code></pre><p>Finds the singular value decomposition of <code>A</code>, <code>A = U * S * V&#39;</code>. If <code>jobu = A</code>, all the columns of <code>U</code> are computed. If <code>jobvt = A</code> all the rows of <code>V&#39;</code> are computed. If <code>jobu = N</code>, no columns of <code>U</code> are computed. If <code>jobvt = N</code> no rows of <code>V&#39;</code> are computed. If <code>jobu = O</code>, <code>A</code> is overwritten with the columns of (thin) <code>U</code>. If <code>jobvt = O</code>, <code>A</code> is overwritten with the rows of (thin) <code>V&#39;</code>. If <code>jobu = S</code>, the columns of (thin) <code>U</code> are computed and returned separately. If <code>jobvt = S</code> the rows of (thin) <code>V&#39;</code> are computed and returned separately. <code>jobu</code> and <code>jobvt</code> can&#39;t both be <code>O</code>.</p><p>Returns <code>U</code>, <code>S</code>, and <code>Vt</code>, where <code>S</code> are the singular values of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1766-L1779">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ggsvd!" href="#Base.LinAlg.LAPACK.ggsvd!"><code>Base.LinAlg.LAPACK.ggsvd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ggsvd!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</code></pre><p>Finds the generalized singular value decomposition of <code>A</code> and <code>B</code>, <code>U&#39;*A*Q = D1*R</code> and <code>V&#39;*B*Q = D2*R</code>. <code>D1</code> has <code>alpha</code> on its diagonal and <code>D2</code> has <code>beta</code> on its diagonal. If <code>jobu = U</code>, the orthogonal/unitary matrix <code>U</code> is computed. If <code>jobv = V</code> the orthogonal/unitary matrix <code>V</code> is computed. If <code>jobq = Q</code>, the orthogonal/unitary matrix <code>Q</code> is computed. If <code>jobu</code>, <code>jobv</code> or <code>jobq</code> is <code>N</code>, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1782-L1792">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ggsvd3!" href="#Base.LinAlg.LAPACK.ggsvd3!"><code>Base.LinAlg.LAPACK.ggsvd3!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ggsvd3!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</code></pre><p>Finds the generalized singular value decomposition of <code>A</code> and <code>B</code>, <code>U&#39;*A*Q = D1*R</code> and <code>V&#39;*B*Q = D2*R</code>. <code>D1</code> has <code>alpha</code> on its diagonal and <code>D2</code> has <code>beta</code> on its diagonal. If <code>jobu = U</code>, the orthogonal/unitary matrix <code>U</code> is computed. If <code>jobv = V</code> the orthogonal/unitary matrix <code>V</code> is computed. If <code>jobq = Q</code>, the orthogonal/unitary matrix <code>Q</code> is computed. If <code>jobu</code>, <code>jobv</code>, or <code>jobq</code> is <code>N</code>, that matrix is not computed. This function requires LAPACK 3.6.0.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L1911-L1920">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.geevx!" href="#Base.LinAlg.LAPACK.geevx!"><code>Base.LinAlg.LAPACK.geevx!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">geevx!(balanc, jobvl, jobvr, sense, A) -&gt; (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)</code></pre><p>Finds the eigensystem of <code>A</code> with matrix balancing. If <code>jobvl = N</code>, the left eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors of <code>A</code> aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed. If <code>balanc = N</code>, no balancing is performed. If <code>balanc = P</code>, <code>A</code> is permuted but not scaled. If <code>balanc = S</code>, <code>A</code> is scaled but not permuted. If <code>balanc = B</code>, <code>A</code> is permuted and scaled. If <code>sense = N</code>, no reciprocal condition numbers are computed. If <code>sense = E</code>, reciprocal condition numbers are computed for the eigenvalues only. If <code>sense = V</code>, reciprocal condition numbers are computed for the right eigenvectors only. If <code>sense = B</code>, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If <code>sense = E,B</code>, the right and left eigenvectors must be computed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2221-L2237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ggev!" href="#Base.LinAlg.LAPACK.ggev!"><code>Base.LinAlg.LAPACK.ggev!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ggev!(jobvl, jobvr, A, B) -&gt; (alpha, beta, vl, vr)</code></pre><p>Finds the generalized eigendecomposition of <code>A</code> and <code>B</code>. If <code>jobvl = N</code>, the left eigenvectors aren&#39;t computed. If <code>jobvr = N</code>, the right eigenvectors aren&#39;t computed. If <code>jobvl = V</code> or <code>jobvr = V</code>, the corresponding eigenvectors are computed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2240-L2247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gtsv!" href="#Base.LinAlg.LAPACK.gtsv!"><code>Base.LinAlg.LAPACK.gtsv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gtsv!(dl, d, du, B)</code></pre><p>Solves the equation <code>A * X = B</code> where <code>A</code> is a tridiagonal matrix with <code>dl</code> on the subdiagonal, <code>d</code> on the diagonal, and <code>du</code> on the superdiagonal.</p><p>Overwrites <code>B</code> with the solution <code>X</code> and returns it.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2414-L2422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gttrf!" href="#Base.LinAlg.LAPACK.gttrf!"><code>Base.LinAlg.LAPACK.gttrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gttrf!(dl, d, du) -&gt; (dl, d, du, du2, ipiv)</code></pre><p>Finds the <code>LU</code> factorization of a tridiagonal matrix with <code>dl</code> on the subdiagonal, <code>d</code> on the diagonal, and <code>du</code> on the superdiagonal.</p><p>Modifies <code>dl</code>, <code>d</code>, and <code>du</code> in-place and returns them and the second superdiagonal <code>du2</code> and the pivoting vector <code>ipiv</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2425-L2433">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gttrs!" href="#Base.LinAlg.LAPACK.gttrs!"><code>Base.LinAlg.LAPACK.gttrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gttrs!(trans, dl, d, du, du2, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> (<code>trans = N</code>), <code>A.&#39; * X = B</code> (<code>trans = T</code>), or <code>A&#39; * X = B</code> (<code>trans = C</code>) using the <code>LU</code> factorization computed by <code>gttrf!</code>. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2436-L2442">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orglq!" href="#Base.LinAlg.LAPACK.orglq!"><code>Base.LinAlg.LAPACK.orglq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orglq!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>LQ</code> factorization after calling <code>gelqf!</code> on <code>A</code>. Uses the output of <code>gelqf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2834-L2839">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orgqr!" href="#Base.LinAlg.LAPACK.orgqr!"><code>Base.LinAlg.LAPACK.orgqr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orgqr!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>QR</code> factorization after calling <code>geqrf!</code> on <code>A</code>. Uses the output of <code>geqrf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2842-L2847">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orgql!" href="#Base.LinAlg.LAPACK.orgql!"><code>Base.LinAlg.LAPACK.orgql!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orgql!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>QL</code> factorization after calling <code>geqlf!</code> on <code>A</code>. Uses the output of <code>geqlf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2850-L2855">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orgrq!" href="#Base.LinAlg.LAPACK.orgrq!"><code>Base.LinAlg.LAPACK.orgrq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orgrq!(A, tau, k = length(tau))</code></pre><p>Explicitly finds the matrix <code>Q</code> of a <code>RQ</code> factorization after calling <code>gerqf!</code> on <code>A</code>. Uses the output of <code>gerqf!</code>. <code>A</code> is overwritten by <code>Q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2858-L2863">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormlq!" href="#Base.LinAlg.LAPACK.ormlq!"><code>Base.LinAlg.LAPACK.ormlq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormlq!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>LQ</code> factorization of <code>A</code> computed using <code>gelqf!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2866-L2873">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormqr!" href="#Base.LinAlg.LAPACK.ormqr!"><code>Base.LinAlg.LAPACK.ormqr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormqr!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QR</code> factorization of <code>A</code> computed using <code>geqrf!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2876-L2883">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormql!" href="#Base.LinAlg.LAPACK.ormql!"><code>Base.LinAlg.LAPACK.ormql!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormql!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QL</code> factorization of <code>A</code> computed using <code>geqlf!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2886-L2893">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ormrq!" href="#Base.LinAlg.LAPACK.ormrq!"><code>Base.LinAlg.LAPACK.ormrq!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ormrq!(side, trans, A, tau, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>RQ</code> factorization of <code>A</code> computed using <code>gerqf!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2896-L2903">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gemqrt!" href="#Base.LinAlg.LAPACK.gemqrt!"><code>Base.LinAlg.LAPACK.gemqrt!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gemqrt!(side, trans, V, T, C)</code></pre><p>Computes <code>Q * C</code> (<code>trans = N</code>), <code>Q.&#39; * C</code> (<code>trans = T</code>), <code>Q&#39; * C</code> (<code>trans = C</code>) for <code>side = L</code> or the equivalent right-sided multiplication for <code>side = R</code> using <code>Q</code> from a <code>QR</code> factorization of <code>A</code> computed using <code>geqrt!</code>. <code>C</code> is overwritten.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L2906-L2913">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.posv!" href="#Base.LinAlg.LAPACK.posv!"><code>Base.LinAlg.LAPACK.posv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">posv!(uplo, A, B) -&gt; (A, B)</code></pre><p>Finds the solution to <code>A * X = B</code> where <code>A</code> is a symmetric or Hermitian positive definite matrix. If <code>uplo = U</code> the upper Cholesky decomposition of <code>A</code> is computed. If <code>uplo = L</code> the lower Cholesky decomposition of <code>A</code> is computed. <code>A</code> is overwritten by its Cholesky decomposition. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3044-L3052">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.potrf!" href="#Base.LinAlg.LAPACK.potrf!"><code>Base.LinAlg.LAPACK.potrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">potrf!(uplo, A)</code></pre><p>Computes the Cholesky (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) decomposition of positive-definite matrix <code>A</code>. <code>A</code> is overwritten and returned with an info code.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3055-L3061">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.potri!" href="#Base.LinAlg.LAPACK.potri!"><code>Base.LinAlg.LAPACK.potri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">potri!(uplo, A)</code></pre><p>Computes the inverse of positive-definite matrix <code>A</code> after calling <code>potrf!</code> to find its (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) Cholesky decomposition.</p><p><code>A</code> is overwritten by its inverse and returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3064-L3072">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.potrs!" href="#Base.LinAlg.LAPACK.potrs!"><code>Base.LinAlg.LAPACK.potrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">potrs!(uplo, A, B)</code></pre><p>Finds the solution to <code>A * X = B</code> where <code>A</code> is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by <code>potrf!</code>. If <code>uplo = U</code> the upper Cholesky decomposition of <code>A</code> was computed. If <code>uplo = L</code> the lower Cholesky decomposition of <code>A</code> was computed. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3075-L3083">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.pstrf!" href="#Base.LinAlg.LAPACK.pstrf!"><code>Base.LinAlg.LAPACK.pstrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pstrf!(uplo, A, tol) -&gt; (A, piv, rank, info)</code></pre><p>Computes the (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) pivoted Cholesky decomposition of positive-definite matrix <code>A</code> with a user-set tolerance <code>tol</code>. <code>A</code> is overwritten by its Cholesky decomposition.</p><p>Returns <code>A</code>, the pivots <code>piv</code>, the rank of <code>A</code>, and an <code>info</code> code. If <code>info = 0</code>, the factorization succeeded. If <code>info = i &gt; 0</code>, then <code>A</code> is indefinite or rank-deficient.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3086-L3096">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.ptsv!" href="#Base.LinAlg.LAPACK.ptsv!"><code>Base.LinAlg.LAPACK.ptsv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ptsv!(D, E, B)</code></pre><p>Solves <code>A * X = B</code> for positive-definite tridiagonal <code>A</code>. <code>D</code> is the diagonal of <code>A</code> and <code>E</code> is the off-diagonal. <code>B</code> is overwritten with the solution <code>X</code> and returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3151-L3157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.pttrf!" href="#Base.LinAlg.LAPACK.pttrf!"><code>Base.LinAlg.LAPACK.pttrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pttrf!(D, E)</code></pre><p>Computes the LDLt factorization of a positive-definite tridiagonal matrix with <code>D</code> as diagonal and <code>E</code> as off-diagonal. <code>D</code> and <code>E</code> are overwritten and returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3160-L3166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.pttrs!" href="#Base.LinAlg.LAPACK.pttrs!"><code>Base.LinAlg.LAPACK.pttrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pttrs!(D, E, B)</code></pre><p>Solves <code>A * X = B</code> for positive-definite tridiagonal <code>A</code> with diagonal <code>D</code> and off-diagonal <code>E</code> after computing <code>A</code>&#39;s LDLt factorization using <code>pttrf!</code>. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3231-L3237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trtri!" href="#Base.LinAlg.LAPACK.trtri!"><code>Base.LinAlg.LAPACK.trtri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trtri!(uplo, diag, A)</code></pre><p>Finds the inverse of (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>A</code> is overwritten with its inverse.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3296-L3303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trtrs!" href="#Base.LinAlg.LAPACK.trtrs!"><code>Base.LinAlg.LAPACK.trtrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trtrs!(uplo, trans, diag, A, B)</code></pre><p>Solves <code>A * X = B</code> (<code>trans = N</code>), <code>A.&#39; * X = B</code> (<code>trans = T</code>), or <code>A&#39; * X = B</code> (<code>trans = C</code>) for (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>B</code> is overwritten with the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3306-L3314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trcon!" href="#Base.LinAlg.LAPACK.trcon!"><code>Base.LinAlg.LAPACK.trcon!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trcon!(norm, uplo, diag, A)</code></pre><p>Finds the reciprocal condition number of (upper if <code>uplo = U</code>, lower if <code>uplo = L</code>) triangular matrix <code>A</code>. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. If <code>norm = I</code>, the condition number is found in the infinity norm. If <code>norm = O</code> or <code>1</code>, the condition number is found in the one norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3575-L3583">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trevc!" href="#Base.LinAlg.LAPACK.trevc!"><code>Base.LinAlg.LAPACK.trevc!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))</code></pre><p>Finds the eigensystem of an upper triangular matrix <code>T</code>. If <code>side = R</code>, the right eigenvectors are computed. If <code>side = L</code>, the left eigenvectors are computed. If <code>side = B</code>, both sets are computed. If <code>howmny = A</code>, all eigenvectors are found. If <code>howmny = B</code>, all eigenvectors are found and backtransformed using <code>VL</code> and <code>VR</code>. If <code>howmny = S</code>, only the eigenvectors corresponding to the values in <code>select</code> are computed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3586-L3596">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trrfs!" href="#Base.LinAlg.LAPACK.trrfs!"><code>Base.LinAlg.LAPACK.trrfs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -&gt; (Ferr, Berr)</code></pre><p>Estimates the error in the solution to <code>A * X = B</code> (<code>trans = N</code>), <code>A.&#39; * X = B</code> (<code>trans = T</code>), <code>A&#39; * X = B</code> (<code>trans = C</code>) for <code>side = L</code>, or the equivalent equations a right-handed <code>side = R</code> <code>X * A</code> after computing <code>X</code> using <code>trtrs!</code>. If <code>uplo = U</code>, <code>A</code> is upper triangular. If <code>uplo = L</code>, <code>A</code> is lower triangular. If <code>diag = N</code>, <code>A</code> has non-unit diagonal elements. If <code>diag = U</code>, all diagonal elements of <code>A</code> are one. <code>Ferr</code> and <code>Berr</code> are optional inputs. <code>Ferr</code> is the forward error and <code>Berr</code> is the backward error, each component-wise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3600-L3611">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.stev!" href="#Base.LinAlg.LAPACK.stev!"><code>Base.LinAlg.LAPACK.stev!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stev!(job, dv, ev) -&gt; (dv, Zmat)</code></pre><p>Computes the eigensystem for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>job = N</code> only the eigenvalues are found and returned in <code>dv</code>. If <code>job = V</code> then the eigenvectors are also found and returned in <code>Zmat</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3772-L3779">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.stebz!" href="#Base.LinAlg.LAPACK.stebz!"><code>Base.LinAlg.LAPACK.stebz!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -&gt; (dv, iblock, isplit)</code></pre><p>Computes the eigenvalues for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. If <code>order = B</code>, eigvalues are ordered within a block. If <code>order = E</code>, they are ordered across all the blocks. <code>abstol</code> can be set as a tolerance for convergence.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3782-L3792">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.stegr!" href="#Base.LinAlg.LAPACK.stegr!"><code>Base.LinAlg.LAPACK.stegr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stegr!(jobz, range, dv, ev, vl, vu, il, iu) -&gt; (w, Z)</code></pre><p>Computes the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev</code> as off-diagonal. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. The eigenvalues are returned in <code>w</code> and the eigenvectors in <code>Z</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3795-L3805">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.stein!" href="#Base.LinAlg.LAPACK.stein!"><code>Base.LinAlg.LAPACK.stein!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stein!(dv, ev_in, w_in, iblock_in, isplit_in)</code></pre><p>Computes the eigenvectors for a symmetric tridiagonal matrix with <code>dv</code> as diagonal and <code>ev_in</code> as off-diagonal. <code>w_in</code> specifies the input eigenvalues for which to find corresponding eigenvectors. <code>iblock_in</code> specifies the submatrices corresponding to the eigenvalues in <code>w_in</code>. <code>isplit_in</code> specifies the splitting points between the submatrix blocks.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L3808-L3816">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.syconv!" href="#Base.LinAlg.LAPACK.syconv!"><code>Base.LinAlg.LAPACK.syconv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syconv!(uplo, A, ipiv) -&gt; (A, work)</code></pre><p>Converts a symmetric matrix <code>A</code> (which has been factorized into a triangular matrix) into two matrices <code>L</code> and <code>D</code>. If <code>uplo = U</code>, <code>A</code> is upper triangular. If <code>uplo = L</code>, it is lower triangular. <code>ipiv</code> is the pivot vector from the triangular factorization. <code>A</code> is overwritten by <code>L</code> and <code>D</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4754-L4762">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sysv!" href="#Base.LinAlg.LAPACK.sysv!"><code>Base.LinAlg.LAPACK.sysv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sysv!(uplo, A, B) -&gt; (B, A, ipiv)</code></pre><p>Finds the solution to <code>A * X = B</code> for symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>. <code>A</code> is overwritten by its Bunch-Kaufman factorization. <code>ipiv</code> contains pivoting information about the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4765-L4773">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sytrf!" href="#Base.LinAlg.LAPACK.sytrf!"><code>Base.LinAlg.LAPACK.sytrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sytrf!(uplo, A) -&gt; (A, ipiv, info)</code></pre><p>Computes the Bunch-Kaufman factorization of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored.</p><p>Returns <code>A</code>, overwritten by the factorization, a pivot vector <code>ipiv</code>, and the error code <code>info</code> which is a non-negative integer. If <code>info</code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code>info</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4776-L4787">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sytri!" href="#Base.LinAlg.LAPACK.sytri!"><code>Base.LinAlg.LAPACK.sytri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sytri!(uplo, A, ipiv)</code></pre><p>Computes the inverse of a symmetric matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>A</code> is overwritten by its inverse.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4790-L4796">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sytrs!" href="#Base.LinAlg.LAPACK.sytrs!"><code>Base.LinAlg.LAPACK.sytrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sytrs!(uplo, A, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> for a symmetric matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4799-L4806">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.hesv!" href="#Base.LinAlg.LAPACK.hesv!"><code>Base.LinAlg.LAPACK.hesv!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hesv!(uplo, A, B) -&gt; (B, A, ipiv)</code></pre><p>Finds the solution to <code>A * X = B</code> for Hermitian matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>. <code>A</code> is overwritten by its Bunch-Kaufman factorization. <code>ipiv</code> contains pivoting information about the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4810-L4818">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.hetrf!" href="#Base.LinAlg.LAPACK.hetrf!"><code>Base.LinAlg.LAPACK.hetrf!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hetrf!(uplo, A) -&gt; (A, ipiv, info)</code></pre><p>Computes the Bunch-Kaufman factorization of a Hermitian matrix <code>A</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored.</p><p>Returns <code>A</code>, overwritten by the factorization, a pivot vector <code>ipiv</code>, and the error code <code>info</code> which is a non-negative integer. If <code>info</code> is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position <code>info</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4821-L4832">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.hetri!" href="#Base.LinAlg.LAPACK.hetri!"><code>Base.LinAlg.LAPACK.hetri!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hetri!(uplo, A, ipiv)</code></pre><p>Computes the inverse of a Hermitian matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>A</code> is overwritten by its inverse.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4835-L4841">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.hetrs!" href="#Base.LinAlg.LAPACK.hetrs!"><code>Base.LinAlg.LAPACK.hetrs!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hetrs!(uplo, A, ipiv, B)</code></pre><p>Solves the equation <code>A * X = B</code> for a Hermitian matrix <code>A</code> using the results of <code>sytrf!</code>. If <code>uplo = U</code>, the upper half of <code>A</code> is stored. If <code>uplo = L</code>, the lower half is stored. <code>B</code> is overwritten by the solution <code>X</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L4844-L4851">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.syev!" href="#Base.LinAlg.LAPACK.syev!"><code>Base.LinAlg.LAPACK.syev!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syev!(jobz, uplo, A)</code></pre><p>Finds the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper triangle of <code>A</code> is used. If <code>uplo = L</code>, the lower triangle of <code>A</code> is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5153-L5159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.syevr!" href="#Base.LinAlg.LAPACK.syevr!"><code>Base.LinAlg.LAPACK.syevr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -&gt; (W, Z)</code></pre><p>Finds the eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code>. If <code>uplo = U</code>, the upper triangle of <code>A</code> is used. If <code>uplo = L</code>, the lower triangle of <code>A</code> is used. If <code>range = A</code>, all the eigenvalues are found. If <code>range = V</code>, the eigenvalues in the half-open interval <code>(vl, vu]</code> are found. If <code>range = I</code>, the eigenvalues with indices between <code>il</code> and <code>iu</code> are found. <code>abstol</code> can be set as a tolerance for convergence.</p><p>The eigenvalues are returned in <code>W</code> and the eigenvectors in <code>Z</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5162-L5174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.sygvd!" href="#Base.LinAlg.LAPACK.sygvd!"><code>Base.LinAlg.LAPACK.sygvd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sygvd!(itype, jobz, uplo, A, B) -&gt; (w, A, B)</code></pre><p>Finds the generalized eigenvalues (<code>jobz = N</code>) or eigenvalues and eigenvectors (<code>jobz = V</code>) of a symmetric matrix <code>A</code> and symmetric positive-definite matrix <code>B</code>. If <code>uplo = U</code>, the upper triangles of <code>A</code> and <code>B</code> are used. If <code>uplo = L</code>, the lower triangles of <code>A</code> and <code>B</code> are used. If <code>itype = 1</code>, the problem to solve is <code>A * x = lambda * B * x</code>. If <code>itype = 2</code>, the problem to solve is <code>A * B * x = lambda * x</code>. If <code>itype = 3</code>, the problem to solve is <code>B * A * x = lambda * x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5178-L5189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.bdsqr!" href="#Base.LinAlg.LAPACK.bdsqr!"><code>Base.LinAlg.LAPACK.bdsqr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bdsqr!(uplo, d, e_, Vt, U, C) -&gt; (d, Vt, U, C)</code></pre><p>Computes the singular value decomposition of a bidiagonal matrix with <code>d</code> on the diagonal and <code>e_</code> on the off-diagonal. If <code>uplo = U</code>, <code>e_</code> is the superdiagonal. If <code>uplo = L</code>, <code>e_</code> is the subdiagonal. Can optionally also compute the product <code>Q&#39; * C</code>.</p><p>Returns the singular values in <code>d</code>, and the matrix <code>C</code> overwritten with <code>Q&#39; * C</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5241-L5250">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.bdsdc!" href="#Base.LinAlg.LAPACK.bdsdc!"><code>Base.LinAlg.LAPACK.bdsdc!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bdsdc!(uplo, compq, d, e_) -&gt; (d, e, u, vt, q, iq)</code></pre><p>Computes the singular value decomposition of a bidiagonal matrix with <code>d</code> on the diagonal and <code>e_</code> on the off-diagonal using a divide and conqueq method. If <code>uplo = U</code>, <code>e_</code> is the superdiagonal. If <code>uplo = L</code>, <code>e_</code> is the subdiagonal. If <code>compq = N</code>, only the singular values are found. If <code>compq = I</code>, the singular values and vectors are found. If <code>compq = P</code>, the singular values and vectors are found in compact form. Only works for real types.</p><p>Returns the singular values in <code>d</code>, and if <code>compq = P</code>, the compact singular vectors in <code>iq</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5309-L5321">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gecon!" href="#Base.LinAlg.LAPACK.gecon!"><code>Base.LinAlg.LAPACK.gecon!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gecon!(normtype, A, anorm)</code></pre><p>Finds the reciprocal condition number of matrix <code>A</code>. If <code>normtype = I</code>, the condition number is found in the infinity norm. If <code>normtype = O</code> or <code>1</code>, the condition number is found in the one norm. <code>A</code> must be the result of <code>getrf!</code> and <code>anorm</code> is the norm of <code>A</code> in the relevant norm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5392-L5399">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gehrd!" href="#Base.LinAlg.LAPACK.gehrd!"><code>Base.LinAlg.LAPACK.gehrd!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gehrd!(ilo, ihi, A) -&gt; (A, tau)</code></pre><p>Converts a matrix <code>A</code> to Hessenberg form. If <code>A</code> is balanced with <code>gebal!</code> then <code>ilo</code> and <code>ihi</code> are the outputs of <code>gebal!</code>. Otherwise they should be <code>ilo = 1</code> and <code>ihi = size(A,2)</code>. <code>tau</code> contains the elementary reflectors of the factorization.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5442-L5449">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.orghr!" href="#Base.LinAlg.LAPACK.orghr!"><code>Base.LinAlg.LAPACK.orghr!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">orghr!(ilo, ihi, A, tau)</code></pre><p>Explicitly finds <code>Q</code>, the orthogonal/unitary matrix from <code>gehrd!</code>. <code>ilo</code>, <code>ihi</code>, <code>A</code>, and <code>tau</code> must correspond to the input/output to <code>gehrd!</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5491-L5496">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gees!" href="#Base.LinAlg.LAPACK.gees!"><code>Base.LinAlg.LAPACK.gees!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gees!(jobvs, A) -&gt; (A, vs, w)</code></pre><p>Computes the eigenvalues (<code>jobvs = N</code>) or the eigenvalues and Schur vectors (<code>jobvs = V</code>) of matrix <code>A</code>. <code>A</code> is overwritten by its Schur form.</p><p>Returns <code>A</code>, <code>vs</code> containing the Schur vectors, and <code>w</code>, containing the eigenvalues.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5737-L5745">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.gges!" href="#Base.LinAlg.LAPACK.gges!"><code>Base.LinAlg.LAPACK.gges!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gges!(jobvsl, jobvsr, A, B) -&gt; (A, B, alpha, beta, vsl, vsr)</code></pre><p>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (<code>jobsvl = V</code>), or right Schur vectors (<code>jobvsr = V</code>) of <code>A</code> and <code>B</code>.</p><p>The generalized eigenvalues are returned in <code>alpha</code> and <code>beta</code>. The left Schur vectors are returned in <code>vsl</code> and the right Schur vectors are returned in <code>vsr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L5749-L5758">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trexc!" href="#Base.LinAlg.LAPACK.trexc!"><code>Base.LinAlg.LAPACK.trexc!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trexc!(compq, ifst, ilst, T, Q) -&gt; (T, Q)</code></pre><p>Reorder the Schur factorization of a matrix. If <code>compq = V</code>, the Schur vectors <code>Q</code> are reordered. If <code>compq = N</code> they are not modified. <code>ifst</code> and <code>ilst</code> specify the reordering of the vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L6057-L6063">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trsen!" href="#Base.LinAlg.LAPACK.trsen!"><code>Base.LinAlg.LAPACK.trsen!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsen!(compq, job, select, T, Q) -&gt; (T, Q, w, s, sep)</code></pre><p>Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If <code>job = N</code>, no condition numbers are found. If <code>job = E</code>, only the condition number for this cluster of eigenvalues is found. If <code>job = V</code>, only the condition number for the invariant subspace is found. If <code>job = B</code> then the condition numbers for the cluster and subspace are found. If <code>compq = V</code> the Schur vectors <code>Q</code> are updated. If <code>compq = N</code> the Schur vectors are not modified. <code>select</code> determines which eigenvalues are in the cluster.</p><p>Returns <code>T</code>, <code>Q</code>, reordered eigenvalues in <code>w</code>, the condition number of the cluster of eigenvalues <code>s</code>, and the condition number of the invariant subspace <code>sep</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L6066-L6081">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.tgsen!" href="#Base.LinAlg.LAPACK.tgsen!"><code>Base.LinAlg.LAPACK.tgsen!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tgsen!(select, S, T, Q, Z) -&gt; (S, T, alpha, beta, Q, Z)</code></pre><p>Reorders the vectors of a generalized Schur decomposition. <code>select</code> specifices the eigenvalues in each cluster.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L6084-L6089">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.LAPACK.trsyl!" href="#Base.LinAlg.LAPACK.trsyl!"><code>Base.LinAlg.LAPACK.trsyl!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">trsyl!(transa, transb, A, B, C, isgn=1) -&gt; (C, scale)</code></pre><p>Solves the Sylvester matrix equation <code>A * X +/- X * B = scale*C</code> where <code>A</code> and <code>B</code> are both quasi-upper triangular. If <code>transa = N</code>, <code>A</code> is not modified. If <code>transa = T</code>, <code>A</code> is transposed. If <code>transa = C</code>, <code>A</code> is conjugate transposed. Similarly for <code>transb</code> and <code>B</code>. If <code>isgn = 1</code>, the equation <code>A * X + X * B = scale * C</code> is solved. If <code>isgn = -1</code>, the equation <code>A * X - X * B = scale * C</code> is solved.</p><p>Returns <code>X</code> (overwriting <code>C</code>) and <code>scale</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38ba1d07918af34e3f02bb67ec1ce62f2d428cdb/base/linalg/lapack.jl#L6123-L6134">source</a></section><footer><hr/><a class="previous" href="parallel.html"><span class="direction">이전글</span><span class="title">Tasks and Parallel Computing</span></a><a class="next" href="constants.html"><span class="direction">다음글</span><span class="title">Constants</span></a></footer></article></body></html>
