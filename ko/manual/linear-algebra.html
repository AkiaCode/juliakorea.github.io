<!DOCTYPE html>
<html lang="ko"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>선형 대수 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-110655381-2', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="/js/jquery-1.8.3.min.js"></script><script src="/js/jquery.word-break-keep-all.min.js"></script><script>$(document).ready(function() { $('p').wordBreakKeepAll(); });</script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">소개글</a></li><li><a class="toctext" href="getting-started.html">시작하기</a></li><li><a class="toctext" href="variables.html">변수</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">정수와 부동소수점으로 표현되는 실수</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">함수</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="methods.html">메소드</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="arrays.html">다차원 배열</a></li><li class="current"><a class="toctext" href="linear-algebra.html">선형 대수</a><ul class="internal"><li><a class="toctext" href="#특수-행렬-1">특수 행렬</a></li><li><a class="toctext" href="#man-linalg-factorizations-1">행렬 분해</a></li></ul></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks</a></li><li><a class="toctext" href="../stdlib/distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/delimitedfiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/sharedarrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/filewatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/crc32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/iterativeeigensolvers.html">Iterative Eigensolvers</a></li><li><a class="toctext" href="../stdlib/unicode.html">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="linear-algebra.html">선형 대수</a></li></ul><a class="edit-page" href="https://github.com/juliakorea/translate-doc/blob/master/src/manual/linear-algebra.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>선형 대수</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Linear-algebra-1" href="#Linear-algebra-1">선형 대수</a></h1><p>다차원 배열 지원에 더불어, Julia는 자주 쓰이고 유용한 여러 선형 대수 연산의 네이티브 구현을 제공한다. <a href="../stdlib/linalg.html#Base.LinAlg.trace"><code>trace</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.det"><code>det</code></a>, <a href="../stdlib/linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a> 등의 기초적 연산을 모두 지원한다:</p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 1 6; 7 8 1]
3×3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia&gt; trace(A)
3

julia&gt; det(A)
104.0

julia&gt; inv(A)
3×3 Array{Float64,2}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077</code></pre><p>또한 고윳값과 고유 벡터 찾기 등의 다른 유용한 연산들도 지원한다:</p><pre><code class="language-julia-repl">julia&gt; A = [-4. -17.; 2. 2.]
2×2 Array{Float64,2}:
 -4.0  -17.0
  2.0    2.0

julia&gt; eigvals(A)
2-element Array{Complex{Float64},1}:
 -1.0 + 5.0im
 -1.0 - 5.0im

julia&gt; eigvecs(A)
2×2 Array{Complex{Float64},2}:
  0.945905+0.0im        0.945905-0.0im
 -0.166924-0.278207im  -0.166924+0.278207im</code></pre><p>이에 더불어, Julia는 여러 <a href="linear-algebra.html#man-linalg-factorizations-1">분해</a>를 제공한다:  선형 방정식 풀이나 행렬 지수 함수 계산 등을 할 때, 행렬을 (성능이나 메모리 등의 이유로) 더 용이한 형태로 사전 분해 함으로써 속도를 높여줄 수 있다. 자세한 내용은 <a href="../stdlib/linalg.html#Base.LinAlg.factorize"><code>factorize</code></a> 문서를 참조하라. 예를 들어:</p><pre><code class="language-julia-repl">julia&gt; A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia&gt; factorize(A)
Base.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:
[1.0 0.0 0.0; -0.15 1.0 0.0; -0.3 -0.132196 1.0]
[-10.0 2.3 4.0; 0.0 2.345 -3.4; 0.0 0.0 -5.24947]</code></pre><p><code>A</code>가 에르미트, 대칭, 삼각, 3중 대각 또는 2중 대각이 아니므로, LU 분해가 가장 좋은 방법일 것이다. 이를 다음과 비교해보자:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; factorize(B)
Base.LinAlg.BunchKaufman{Float64,Array{Float64,2}}
D factor:
3×3 Tridiagonal{Float64,Array{Float64,1}}:
 -1.64286   0.0   ⋅
  0.0      -2.8  0.0
   ⋅        0.0  5.0
U factor:
3×3 Base.LinAlg.UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.142857  -0.8
 0.0  1.0       -0.6
 0.0  0.0        1.0
permutation:
3-element Array{Int64,1}:
 1
 2
 3</code></pre><p>여기서는 Julia가 <code>B</code>가 대칭임을 감지하여 더 적절한 분해를 사용하였다. 행렬의 특성(예를 들어 대칭, 3중 대각 등)을 알고 있는 경우 더 효율적인 코드를 작성할 수 있는 경우가 많이 있다. Julia는 행렬에 태그를 붙여 이러한 특성들을 표기할 수 있도록 해주는 특수 타입들을 제공한다. 예를 들어:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0</code></pre><p><code>sB</code>는 (실)대칭인 행렬로 태그되었다. 따라서 이후에 고윳값 분해나 벡터와의 곱 등을 할 때, 참조하는 데이터를 반으로 줄임으로써 계산을 효율적으로 할 수 있다. 예를 들어:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; x = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; sB\x
3-element Array{Float64,1}:
 -1.7391304347826084
 -1.1086956521739126
 -1.4565217391304346</code></pre><p>여기서 <code>\</code> (왼쪽나누기) 연산은 선형 해법을 계산한다. 행렬의 <em>전치</em>를 벡터로 왼쪽나누기 하거나, 행렬간의 선형 해법에서 전치가 있는 경우 등에 대해 Julia의 파서는 특수화된 함수를 배정하며, 이는 행렬 타입에 따라 더 특수화 되는 경우가 많다. 예를 들어, 똑같은 왼쪽나누기 연산자를 사용했음에도 불구하고, <code>A\B</code>는 <a href="../stdlib/linalg.html#Base.LinAlg.A_ldiv_B!"><code>Base.LinAlg.A_ldiv_B!</code></a>를 호출하는 반면 <code>A&#39;\B</code>는 <a href="../stdlib/linalg.html#Base.Ac_ldiv_B"><code>Base.LinAlg.Ac_ldiv_B</code></a>를 호출한다. 행렬에 대해서도 마찬가지이다: <code>A.&#39;\B.&#39;</code>는 <a href="../stdlib/linalg.html#Base.At_ldiv_Bt"><code>Base.LinAlg.At_ldiv_Bt</code></a>를 호출한다. 왼쪽나누기 연산자는 강력하여 간소하고 읽기 쉬우면서도 모든 종류의 선형 방정식의 풀이할 수 있을 정도로 충분히 유연한 코드를 작성하기 쉽게 해 준다.</p><h2><a class="nav-anchor" id="특수-행렬-1" href="#특수-행렬-1">특수 행렬</a></h2><p>선형대수에서는 <a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3274">특수한 대칭성과 구조를 가진 행렬</a>이 종종 등장하는데, 행렬의 종류에 따라 여러가지 행렬 분해와 연관지을 수 있다. Julia는 특수 행렬 타입의 풍부한 컬렉션을 제공하며, 이를 통해 특정 행렬 타입에 특수화된 루틴으로 계산을 빠르게 할 수 있도록 해준다.</p><p>다음은 Julia에 구현된 특수 행렬의 종류와, 이들에 대해 최적화 된 LAPACK 메소드로의 후크 여부를 요약한 표이다.</p><table><tr><th>행렬 타입</th><th>설명</th></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Symmetric"><code>Symmetric</code></a></td><td><a href="https://ko.wikipedia.org/wiki/%EB%8C%80%EC%B9%AD%ED%96%89%EB%A0%AC">대칭 행렬</a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a></td><td><a href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%A5%B4%EB%AF%B8%ED%8A%B8_%ED%96%89%EB%A0%AC">에르미트 행렬</a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.UpperTriangular"><code>UpperTriangular</code></a></td><td>상 <a href="https://ko.wikipedia.org/wiki/%EC%82%BC%EA%B0%81%ED%96%89%EB%A0%AC">삼각 행렬</a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.LowerTriangular"><code>LowerTriangular</code></a></td><td>하 <a href="https://ko.wikipedia.org/wiki/%EC%82%BC%EA%B0%81%ED%96%89%EB%A0%AC">삼각 행렬</a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a></td><td><a href="https://ko.wikipedia.org/wiki/3%EC%A4%91%EB%8C%80%EA%B0%81%ED%96%89%EB%A0%AC">3중 대각 행렬</a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>대칭 3중 삼각 행렬</td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Bidiagonal"><code>Bidiagonal</code></a></td><td>상/하 <a href="https://en.wikipedia.org/wiki/Bidiagonal_matrix">2중 대각 행렬</a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Diagonal"><code>Diagonal</code></a></td><td><a href="https://ko.wikipedia.org/wiki/%EB%8C%80%EA%B0%81%ED%96%89%EB%A0%AC">대각 행렬</a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.UniformScaling"><code>UniformScaling</code></a></td><td><a href="https://en.wikipedia.org/wiki/Uniform_scaling">균일 스케일링 연산자</a></td></tr></table><h3><a class="nav-anchor" id="기초-연산-1" href="#기초-연산-1">기초 연산</a></h3><table><tr><th>행렬 타입</th><th><code>+</code></th><th><code>-</code></th><th><code>*</code></th><th><code>\</code></th><th>그 외 최적화된 함수</th></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Symmetric"><code>Symmetric</code></a></td><td></td><td></td><td></td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="../stdlib/linalg.html#Base.sqrt-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>sqrt</code></a>, <a href="../stdlib/linalg.html#Base.exp-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}"><code>exp</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a></td><td></td><td></td><td></td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="../stdlib/linalg.html#Base.sqrt-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Real}"><code>sqrt</code></a>, <a href="../stdlib/linalg.html#Base.exp-Tuple{Union{DenseArray{#s43,2}, Base.ReinterpretArray{#s43,2,S,A} where S, Base.ReshapedArray{#s43,2,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray}, SubArray{#s43,2,A,I,L} where L} where I&lt;:Tuple{Vararg{Union{Int64, AbstractRange{Int64}, Base.AbstractCartesianIndex},N} where N} where A&lt;:Union{Base.ReshapedArray{T,N,A,MI} where MI&lt;:Tuple{Vararg{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64},N} where N} where A&lt;:Union{SubArray{T,N,P,I,true} where I&lt;:Tuple{Union{Base.Slice, UnitRange},Vararg{Any,N} where N} where P where N where T, DenseArray} where N where T, DenseArray} where #s43&lt;:Union{Complex{Float32}, Complex{Float64}, Float32, Float64}}"><code>exp</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.UpperTriangular"><code>UpperTriangular</code></a></td><td></td><td></td><td>MV</td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.det"><code>det</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.LowerTriangular"><code>LowerTriangular</code></a></td><td></td><td></td><td>MV</td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.det"><code>det</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td><a href="../stdlib/linalg.html#Base.LinAlg.eigmax"><code>eigmax</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.eigmin"><code>eigmin</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Bidiagonal"><code>Bidiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Diagonal"><code>Diagonal</code></a></td><td>M</td><td>M</td><td>MV</td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv-Tuple{AbstractArray{T,2} where T}"><code>inv</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.det"><code>det</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.logdet"><code>logdet</code></a>, <a href="../stdlib/math.html#Base.:/"><code>/</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.UniformScaling"><code>UniformScaling</code></a></td><td>M</td><td>M</td><td>MVS</td><td>MVS</td><td><a href="../stdlib/math.html#Base.:/"><code>/</code></a></td></tr></table><p>범례:</p><table><tr><th>기호</th><th>설명</th></tr><tr><td>M (matrix, 행뎔)</td><td>최적화된 행렬-행렬 연산을 사용할 수 있음</td></tr><tr><td>V (vector, 벡터)</td><td>최적화된 행렬-벡터 연산을 사용할 수 있음</td></tr><tr><td>S (scalar, 스칼라)</td><td>최적화된 행렬-스칼라 연산을 사용할 수 있음</td></tr></table><h3><a class="nav-anchor" id="행렬-분해-1" href="#행렬-분해-1">행렬 분해</a></h3><table><tr><th>행렬 타입</th><th>LAPACK</th><th><a href="../stdlib/linalg.html#Base.LinAlg.eig"><code>eig</code></a></th><th><a href="../stdlib/linalg.html#Base.LinAlg.eigvals"><code>eigvals</code></a></th><th><a href="../stdlib/linalg.html#Base.LinAlg.eigvecs"><code>eigvecs</code></a></th><th><a href="../stdlib/linalg.html#Base.LinAlg.svd"><code>svd</code></a></th><th><a href="../stdlib/linalg.html#Base.LinAlg.svdvals"><code>svdvals</code></a></th></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Symmetric"><code>Symmetric</code></a></td><td>SY</td><td></td><td>ARI</td><td></td><td></td><td></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a></td><td>HE</td><td></td><td>ARI</td><td></td><td></td><td></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.UpperTriangular"><code>UpperTriangular</code></a></td><td>TR</td><td>A</td><td>A</td><td>A</td><td></td><td></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.LowerTriangular"><code>LowerTriangular</code></a></td><td>TR</td><td>A</td><td>A</td><td>A</td><td></td><td></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>ST</td><td>A</td><td>ARI</td><td>AV</td><td></td><td></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a></td><td>GT</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Bidiagonal"><code>Bidiagonal</code></a></td><td>BD</td><td></td><td></td><td></td><td>A</td><td>A</td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Diagonal"><code>Diagonal</code></a></td><td>DI</td><td></td><td>A</td><td></td><td></td><td></td></tr></table><p>범례:</p><table><tr><th>기호</th><th>설명</th><th>예시</th></tr><tr><td>A (all, 모두)</td><td>모든 특성 값 및 특성 벡터를 찾는 최적화된 메소드를 사용할 수 있음</td><td>예) <code>eigvals(M)</code></td></tr><tr><td>R (range, 범위)</td><td><code>il</code>번째에서 <code>ih</code>번째 사이의 특성 값을 찾는 최적화된 메소드를 사용할 수 있음</td><td><code>eigvals(M, il, ih)</code></td></tr><tr><td>I (interval, 구간)</td><td>구간 [<code>vl</code>, <code>vh</code>] 사이의 특성 값을 찾는 최적화된 메소드를 사용할 수 있음</td><td><code>eigvals(M, vl, vh)</code></td></tr><tr><td>V (vectors, 벡터)</td><td>특성 값들 <code>x=[x1, x2,...]</code>에 해당하는 특성 벡터들을 찾는 최적화된 메소드를 사용할 수 있음</td><td><code>eigvecs(M, x)</code></td></tr></table><h3><a class="nav-anchor" id="균일-스케일링-연산자-1" href="#균일-스케일링-연산자-1">균일 스케일링 연산자</a></h3><p><a href="../stdlib/linalg.html#Base.LinAlg.UniformScaling"><code>UniformScaling</code></a> 연산자는 스칼라와 단위 행렬의 곱 <code>λ*I</code>를 나타낸다. 항등 연산자 <code>I</code> 는 상수로 정의되며 <code>UniformScaling</code> 의 인스턴스이다. <code>UniformScaling</code> 연산자의 크기는 제네릭하며 이항 연산자 <a href="../stdlib/math.html#Base.:+"><code>+</code></a>, <a href="../stdlib/math.html#Base.:--Tuple{Any}"><code>-</code></a>, <a href="../stdlib/strings.html#Base.:*-Tuple{Union{Char, AbstractString},Vararg{Union{Char, AbstractString},N} where N}"><code>*</code></a>, <a href="../stdlib/linalg.html#Base.:\\-Tuple{AbstractArray{T,2} where T,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>\</code></a> 에서 다른 행렬과 일치하도록 결정된다. <code>A+I</code> and <code>A-I</code> 는 <code>A</code> 가 정사각 행렬임을 의미한다. 항등 연산자 <code>I</code>를 곱하는 것은 (스케일링 비율이 1임을 체크하는 것을 제외하면) noop이며 따라서 오버헤드가 거의 없다.</p><p><code>UniformScaling</code> 연산자가 어떻게 사용되는지 살펴보자:</p><pre><code class="language-julia-repl">julia&gt; U = UniformScaling(2);

julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; a + U
2×2 Array{Int64,2}:
 3  2
 3  6

julia&gt; a * U
2×2 Array{Int64,2}:
 2  4
 6  8

julia&gt; [a U]
2×4 Array{Int64,2}:
 1  2  2  0
 3  4  0  2

julia&gt; b = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; b - U
ERROR: DimensionMismatch(&quot;matrix is not square: dimensions are (2, 3)&quot;)
Stacktrace:
 [1] checksquare at ./linalg/linalg.jl:220 [inlined]
 [2] -(::Array{Int64,2}, ::UniformScaling{Int64}) at ./linalg/uniformscaling.jl:156
 [3] top-level scope</code></pre><h2><a class="nav-anchor" id="man-linalg-factorizations-1" href="#man-linalg-factorizations-1">행렬 분해</a></h2><p><a href="https://en.wikipedia.org/wiki/Matrix_decomposition">행렬 분해</a>는 주어진 행렬을 여러 행렬의 곱으로 분해하는 것이며, 선형 대수의 중심이 되는 개념 중 하나이다.</p><p>아래는 Julia에 구현된 행렬 분해를 요약한 표이다. 각 분해와 연관된 메소드에 관한 자세한 내용은 표준 라이브러리 문서의 <a href="../stdlib/linalg.html#Linear-Algebra-1">선형 대수</a> 섹션을 참조하기 바란다.</p><table><tr><th>종류</th><th>설명</th></tr><tr><td><code>Cholesky</code></td><td><a href="https://ko.wikipedia.org/wiki/%EC%88%84%EB%A0%88%EC%8A%A4%ED%82%A4_%EB%B6%84%ED%95%B4">숄레스키 분해</a></td></tr><tr><td><code>CholeskyPivoted</code></td><td><a href="https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B2%97">피벗</a> 숄레스키 분해</td></tr><tr><td><code>LU</code></td><td><a href="https://ko.wikipedia.org/wiki/LU_%EB%B6%84%ED%95%B4">LU 분해</a></td></tr><tr><td><code>LUTridiagonal</code></td><td><a href="../stdlib/linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a> 행렬에 대한 LU 분해</td></tr><tr><td><code>QR</code></td><td><a href="https://ko.wikipedia.org/wiki/QR_%EB%B6%84%ED%95%B4">QR 분해</a></td></tr><tr><td><code>QRCompactWY</code></td><td>QR 분해의 컴팩트 WY 폼</td></tr><tr><td><code>QRPivoted</code></td><td>피벗 QR 분해</td></tr><tr><td><code>Hessenberg</code></td><td><a href="http://mathworld.wolfram.com/HessenbergDecomposition.html">헤센베르크 분해</a></td></tr><tr><td><code>Eigen</code></td><td><a href="https://en.wikipedia.org/wiki/Eigendecomposition_(matrix)">고윳값 분해</a></td></tr><tr><td><code>SVD</code></td><td><a href="https://ko.wikipedia.org/wiki/%ED%8A%B9%EC%9E%87%EA%B0%92">특이값 분해</a></td></tr><tr><td><code>GeneralizedSVD</code></td><td><a href="https://en.wikipedia.org/wiki/Generalized_singular_value_decomposition#Higher_order_version">일반화된 특이값 분해</a></td></tr></table><footer><hr/><a class="previous" href="arrays.html"><span class="direction">이전글</span><span class="title">다차원 배열</span></a><a class="next" href="missing.html"><span class="direction">다음글</span><span class="title">Missing Values</span></a></footer></article></body></html>
