

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="fb:app_id" content="685509058259607" />

  
  <title>정수와 부동소수점으로 표현되는 실수</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/julia.css" type="text/css" />
  
    <link rel="top" title="None" href="../index.html"/>
        <link rel="next" title="수학 연산들과 기본적인 함수들" href="mathematical-operations.html"/>
        <link rel="prev" title="변수" href="variables.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../index.html" class="fa fa-home"> Julia Language</a>
        -->
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">소개 글</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">시작하기</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting-started.html#id2">다른 읽을 거리</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="variables.html">변수</a><ul>
<li class="toctree-l2"><a class="reference internal" href="variables.html#id2">변수명의 허용범위</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html#id3">코딩 컨벤션</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">정수와 부동소수점으로 표현되는 실수</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">정수</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">부동소수점으로 표현되는 실수</a></li>
<li class="toctree-l2"><a class="reference internal" href="#man-arbitrary-precision-arithmetic">임의 정밀도 연산</a></li>
<li class="toctree-l2"><a class="reference internal" href="#man-numeric-literal-coefficients">수치형 리터럴 계수</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id17">리터럴 0와 1</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mathematical-operations.html">수학 연산들과 기본적인 함수들</a><ul>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#id2">산술 연산자</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#id3">비트 연산자</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#id4">갱신 연산자</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#man-numeric-comparisons">수치 비교</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#man-numerical-conversions">수치 변환</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#man-elementary-functions">기초 함수</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="complex-and-rational-numbers.html">복소수와 유리수</a><ul>
<li class="toctree-l2"><a class="reference internal" href="complex-and-rational-numbers.html#man-complex-numbers">복소수</a></li>
<li class="toctree-l2"><a class="reference internal" href="complex-and-rational-numbers.html#man-rational-numbers">유리수</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="strings.html">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="strings.html#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functions.html#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#the-return-keyword">The <tt class="docutils literal"><span class="pre">return</span></tt> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="control-flow.html">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="variables-and-scoping.html">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="variables-and-scoping.html#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables-and-scoping.html#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables-and-scoping.html#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="types.html#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="methods.html">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="methods.html#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#function-like-objects">Function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="constructors.html">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#constructors-and-conversion">Constructors and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="conversion-and-promotion.html">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="conversion-and-promotion.html#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion-and-promotion.html#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interfaces.html">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="interfaces.html#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="interfaces.html#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="interfaces.html#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="modules.html#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#markdown-syntax-notes">Markdown Syntax Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="metaprogramming.html">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="arrays.html">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="arrays.html#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="linear-algebra.html">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="linear-algebra.html#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="linear-algebra.html#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="networking-and-streams.html">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#io-output-contextual-properties">IO Output Contextual Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="parallel-computing.html">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#remote-references-and-abstractchannels">Remote references and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#remote-references-and-distributed-garbage-collection">Remote References and Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#id2">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dates.html">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="dates.html#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#period-types">Period Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="running-external-programs.html">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="running-external-programs.html#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="running-external-programs.html#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="running-external-programs.html#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#some-examples-of-c-wrappers">Some Examples of C Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#handling-operating-system-variation">Handling Operating System Variation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interacting-with-julia.html">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="interacting-with-julia.html#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="interacting-with-julia.html#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="interacting-with-julia.html#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="embedding.html">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="packages.html">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="packages.html#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="packages.html#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="packages.html#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="profile.html">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="profile.html#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile.html#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile.html#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile.html#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="profile.html#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacktraces.html">Stack Traces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="stacktraces.html#viewing-a-stack-trace">Viewing a stack trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="stacktraces.html#extracting-useful-information">Extracting useful information</a></li>
<li class="toctree-l2"><a class="reference internal" href="stacktraces.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="stacktraces.html#comparison-with-backtrace">Comparison with <tt class="docutils literal"><span class="pre">backtrace()</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="performance-tips.html">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <tt class="docutils literal"><span class="pre">&#64;time</span></tt> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#code-warntype"><tt class="docutils literal"><span class="pre">&#64;code_warntype</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="workflow-tips.html">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="workflow-tips.html#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="workflow-tips.html#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#append-to-names-of-functions-that-modify-their-arguments">Append <tt class="docutils literal"><span class="pre">!</span></tt> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <tt class="docutils literal"><span class="pre">base/</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#do-not-write-x-f-x">Do not write <tt class="docutils literal"><span class="pre">x-&gt;f(x)</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="faq.html#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="noteworthy-differences.html#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="noteworthy-differences.html#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="noteworthy-differences.html#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="noteworthy-differences.html#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="unicode-input.html">Unicode Input</a></li>
</ul>
<ul class="simple">
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../devdocs/reflection.html">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devdocs/julia.html">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/init.html">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/eval.html">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/ast.html">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/types.html">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/object.html">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/functions.html">Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/callconv.html">Calling Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/cartesian.html">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/meta.html">Talking to the compiler (the <tt class="docutils literal"><span class="pre">:meta</span></tt> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/subarrays.html">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/sysimg.html">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/llvm.html">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/boundscheck.html">Bounds checking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../devdocs/C.html">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../phdthesis/chap6.html">결론</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../phdthesis/chap6.html#id2">성능</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phdthesis/chap6.html#id3">앞으로 할 작업들</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phdthesis/chap6.html#id4">프로젝트 상황</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Julia Language</a>
      </nav>



      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>정수와 부동소수점으로 표현되는 실수</li>
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="#" onclick="blame('manual/integers-and-floating-point-numbers')" rel="nofollow"> 원문 보기</a>
            
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="man-integers-and-floating-point-numbers">
<span id="id1"></span><h1>정수와 부동소수점으로 표현되는 실수<a class="headerlink" href="#man-integers-and-floating-point-numbers" title="Permalink to this headline">¶</a></h1>
<p>정수와 부동소수점(floating-point)으로 표현되는 실수는
수치 연산에 있어서 가장 기본적인 구성 요소이다.
이와 같은 값들의 Julia 내부에서의 내장 표현은
숫자 프리미티브(numeric primitives)이라고 하고,
실수나 부동소수점처럼 코드상에서 즉각적으로 표현되는 값들은
수치형 리터럴(numeric literal)이라고 알려져 있다.
예를 들면, <tt class="docutils literal"><span class="pre">1</span></tt>은 정수형 리터럴이지만,
<tt class="docutils literal"><span class="pre">1.0</span></tt>은 부동소수점 리터럴이다;
그리고 위 리터럴들이 바이너리 형태로 메모리상에서 표현되는 객체(object)를
숫자 프리미티브(numeric primitives)라고 한다.</p>
<p>Julia는 넓은 범위의 기본 수치 타입과
수치 연산자, 그리고 비트 연산자를 모두 제공한다.
또한 전 문장에서 언급한 타입과 연산자에 기초한
표준 수학 함수들도 내장하고 있다.
현대의 컴퓨터에서 기본으로 제공되는
Julia에 내장된 표준 수학 함수들은
Julia로 하여금 연산 자원을 최대한 활용하도록 할 수 있도록 한다.
게다가, Julia는 하드웨어에서 기본적으로 표현하지 못하는
숫자들을 표현할 수 있게 만든
<a class="reference internal" href="#man-arbitrary-precision-arithmetic"><em>임의 정밀도 연산</em></a>도 지원한다.
그러나, <a class="reference internal" href="#man-arbitrary-precision-arithmetic"><em>임의 정밀도 연산</em></a>을 사용하면
성능상으로 느려질 수 있다.</p>
<p>다음은 Julia에서 기본적으로 지원하는 타입이다:</p>
<ul class="simple">
<li><strong>정수형 타입:</strong></li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="12%" />
<col width="14%" />
<col width="22%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">타입</th>
<th class="head">부호여부</th>
<th class="head">비트 수</th>
<th class="head">최솟값</th>
<th class="head">최댓값</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Int8</span></tt></td>
<td>✓</td>
<td>8</td>
<td>-2^7</td>
<td>2^7 - 1</td>
</tr>
<tr class="row-odd"><td><tt class="xref jl jl-class docutils literal"><span class="pre">UInt8</span></tt></td>
<td>&nbsp;</td>
<td>8</td>
<td>0</td>
<td>2^8 - 1</td>
</tr>
<tr class="row-even"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Int16</span></tt></td>
<td>✓</td>
<td>16</td>
<td>-2^15</td>
<td>2^15 - 1</td>
</tr>
<tr class="row-odd"><td><tt class="xref jl jl-class docutils literal"><span class="pre">UInt16</span></tt></td>
<td>&nbsp;</td>
<td>16</td>
<td>0</td>
<td>2^16 - 1</td>
</tr>
<tr class="row-even"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Int32</span></tt></td>
<td>✓</td>
<td>32</td>
<td>-2^31</td>
<td>2^31 - 1</td>
</tr>
<tr class="row-odd"><td><tt class="xref jl jl-class docutils literal"><span class="pre">UInt32</span></tt></td>
<td>&nbsp;</td>
<td>32</td>
<td>0</td>
<td>2^32 - 1</td>
</tr>
<tr class="row-even"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Int64</span></tt></td>
<td>✓</td>
<td>64</td>
<td>-2^63</td>
<td>2^63 - 1</td>
</tr>
<tr class="row-odd"><td><tt class="xref jl jl-class docutils literal"><span class="pre">UInt64</span></tt></td>
<td>&nbsp;</td>
<td>64</td>
<td>0</td>
<td>2^64 - 1</td>
</tr>
<tr class="row-even"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Int128</span></tt></td>
<td>✓</td>
<td>128</td>
<td>-2^127</td>
<td>2^127 - 1</td>
</tr>
<tr class="row-odd"><td><tt class="xref jl jl-class docutils literal"><span class="pre">UInt128</span></tt></td>
<td>&nbsp;</td>
<td>128</td>
<td>0</td>
<td>2^128 - 1</td>
</tr>
<tr class="row-even"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Bool</span></tt></td>
<td>N/A</td>
<td>8</td>
<td><tt class="docutils literal"><span class="pre">false</span></tt> (0)</td>
<td><tt class="docutils literal"><span class="pre">true</span></tt> (1)</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><strong>부동소수점 타입:</strong></li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="19%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">타입</th>
<th class="head">정밀도</th>
<th class="head">비트수</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Float16</span></tt></td>
<td><a class="reference external" href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half</a></td>
<td>16</td>
</tr>
<tr class="row-odd"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Float32</span></tt></td>
<td><a class="reference external" href="https://en.wikipedia.org/wiki/Single_precision_floating-point_format">single</a></td>
<td>32</td>
</tr>
<tr class="row-even"><td><tt class="xref jl jl-class docutils literal"><span class="pre">Float64</span></tt></td>
<td><a class="reference external" href="https://en.wikipedia.org/wiki/Double_precision_floating-point_format">double</a></td>
<td>64</td>
</tr>
</tbody>
</table>
<p>추가적으로, <a class="reference internal" href="complex-and-rational-numbers.html#man-complex-and-rational-numbers"><em>복소수와 유리수</em></a> 는 위에서 언급한
타입에 기초하여 만들어졌다.
모든 기본 수치 타입들은 유연하고, 쉽게 확장이 가능한
<a class="reference internal" href="conversion-and-promotion.html#man-conversion-and-promotion"><em>type promotion system</em></a> 덕분에
명시적인 캐스팅(explicit casting) 없이 자유롭게 상호운용이 가능하다.</p>
<div class="section" id="id2">
<h2>정수<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>정수 리터럴은 다음과 같은 표준적인 방식으로 표현한다:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">1234</span>
<span class="mi">1234</span>
</pre></div>
</div>
<p>정수 리터럴은 해당 시스템이
32비트 아키텍처인지 혹은 64비트 아키텍처인지에 따라
타입이 결정된다.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="c"># 32비트 시스템:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kt">Int32</span>

<span class="c"># 64비트 시스템:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kt">Int64</span>
</pre></div>
</div>
<p>Julia의 내부 변수 <tt class="xref jl jl-const docutils literal"><span class="pre">WORD_SIZE</span></tt>는 해당 시스템이
32비트인지 64비트인지 알려주는 역할을 한다.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="c"># 32비트 시스템:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">WORD_SIZE</span>
<span class="mi">32</span>

<span class="c"># 64비트 시스템:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">WORD_SIZE</span>
<span class="mi">64</span>
</pre></div>
</div>
<p>Julia는 부호가 있는 정수형과 부호가 없는 정수형을 위해
<tt class="xref jl jl-class docutils literal"><span class="pre">Int</span></tt>와 <tt class="xref jl jl-class docutils literal"><span class="pre">UInt</span></tt>라는 타입 또한 정의하고 있다.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="c"># 32비트 시스템:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Int</span>
<span class="kt">Int32</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">UInt</span>
<span class="n">UInt32</span>


<span class="c"># 64비트 시스템:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Int</span>
<span class="kt">Int64</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="n">UInt</span>
<span class="n">UInt64</span>
</pre></div>
</div>
<p>32비트로 표현할 수 없지만 64비트로 표현이 가능한 큰 정수형 리터럴은
시스템의 타입과는 상관없이 항상 64비트를 생성한다.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="c"># 32비트 혹은 64비트 시스템:</span>
<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="mi">3000000000</span><span class="p">)</span>
<span class="kt">Int64</span>
</pre></div>
</div>
<p>부호가 없는 정수형의 입출력은 항상 <tt class="docutils literal"><span class="pre">0x</span></tt>라는 접두어가 붙으며
16진수는 <tt class="docutils literal"><span class="pre">0-9a-f</span></tt>범위의 숫자와 문자를 쓴다.
(입력할 때 대문자 <tt class="docutils literal"><span class="pre">A-F</span></tt>도 쓸 수 있다.)
부호가 없는 값의 크기는 헥사 문자열을 쓴 개수에 따라 결정한다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mh">0x1</span>
<span class="mh">0x01</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">UInt8</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mh">0x123</span>
<span class="mh">0x0123</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">UInt16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mh">0x1234567</span>
<span class="mh">0x01234567</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">UInt32</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mh">0x123456789abcdef</span>
<span class="mh">0x0123456789abcdef</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">UInt64</span>
</pre></div>
</div>
<p>일반적으로 부호가 없는 16진수 정수 리터럴을 쓸 때,
단순히 정수를 표현하기 보다는
사람들은 고정된 바이트 시퀀스(fixed numeric byte sequence)를
표현하기 위해 16진수를 쓰는 경향이 있기 때문에,
위와 같이 부호가 없는 정수형에 16진수형태를 결합시키도록 하였다.</p>
<p><tt class="xref jl jl-data docutils literal"><span class="pre">ans</span></tt>가 대화형 실행 환경에서 가장 최근에 실행된 표현식의 결과를
나타내었다는 것을 떠올려보면, 위의 Julia 코드는 다른 환경에서는
제대로 실행이 안될 것이라는 것을 알 수 있다.</p>
<p>Julia는 2진수와 8진수 리터럴 또한 지원한다:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mb">0b10</span>
<span class="mh">0x02</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">UInt8</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mo">0o10</span>
<span class="mh">0x08</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="n">UInt8</span>
</pre></div>
</div>
<p>정수형과 같은 기본 수치 타입의 최소값과 최대값은
<tt class="xref jl jl-func docutils literal"><span class="pre">typemin()</span></tt>과 <tt class="xref jl jl-func docutils literal"><span class="pre">typemax()</span></tt>함수를 통해 알 수 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Int32</span><span class="p">),</span> <span class="nb">typemax</span><span class="p">(</span><span class="kt">Int32</span><span class="p">))</span>
<span class="p">(</span><span class="o">-</span><span class="mi">2147483648</span><span class="p">,</span><span class="mi">2147483647</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">T</span> <span class="k">in</span> <span class="p">[</span><span class="kt">Int8</span><span class="p">,</span><span class="kt">Int16</span><span class="p">,</span><span class="kt">Int32</span><span class="p">,</span><span class="kt">Int64</span><span class="p">,</span><span class="n">Int128</span><span class="p">,</span><span class="n">UInt8</span><span class="p">,</span><span class="n">UInt16</span><span class="p">,</span><span class="n">UInt32</span><span class="p">,</span><span class="n">UInt64</span><span class="p">,</span><span class="n">UInt128</span><span class="p">]</span>
         <span class="n">println</span><span class="p">(</span><span class="s">&quot;</span><span class="si">$</span><span class="s">(lpad(T,7)): [</span><span class="si">$</span><span class="s">(typemin(T)),</span><span class="si">$</span><span class="s">(typemax(T))]&quot;</span><span class="p">)</span>
       <span class="k">end</span>
   <span class="kt">Int8</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">128</span><span class="p">,</span><span class="mi">127</span><span class="p">]</span>
  <span class="kt">Int16</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">32768</span><span class="p">,</span><span class="mi">32767</span><span class="p">]</span>
  <span class="kt">Int32</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">2147483648</span><span class="p">,</span><span class="mi">2147483647</span><span class="p">]</span>
  <span class="kt">Int64</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">,</span><span class="mi">9223372036854775807</span><span class="p">]</span>
 <span class="n">Int128</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">170141183460469231731687303715884105728</span><span class="p">,</span><span class="mi">170141183460469231731687303715884105727</span><span class="p">]</span>
  <span class="n">UInt8</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">]</span>
 <span class="n">UInt16</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">65535</span><span class="p">]</span>
 <span class="n">UInt32</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4294967295</span><span class="p">]</span>
 <span class="n">UInt64</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">18446744073709551615</span><span class="p">]</span>
<span class="n">UInt128</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">340282366920938463463374607431768211455</span><span class="p">]</span>
</pre></div>
</div>
<p><tt class="xref jl jl-func docutils literal"><span class="pre">typemin()</span></tt>과 <tt class="xref jl jl-func docutils literal"><span class="pre">typemax()</span></tt>가 제공하는 값들은
항상 매개변수의 타입과 같은 타입을 가진다.
(위 예제에서 쓰는 <a class="reference internal" href="control-flow.html#man-loops"><em>for loops</em></a>,
<a class="reference internal" href="strings.html#man-strings"><em>Strings</em></a>, <a class="reference internal" href="strings.html#man-string-interpolation"><em>Interpolation</em></a>과 같은 표현들은 아직 소개하지 않은 것들이다.
그러나 약간의 프로그래밍 지식이 있다면 이해하기에 별 문제가 없을 것이다.)</p>
<div class="section" id="overflow">
<h3>오버플로우(Overflow) 동작<a class="headerlink" href="#overflow" title="Permalink to this headline">¶</a></h3>
<p>Julia에서는 주어진 타입에서 표현할 수 있는 값을 넘어서게 되면
다음과 같이 주어진 범위를 벗어나지 않는(wraparound) 동작을 보여준다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">typemax</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span>
<span class="mi">9223372036854775807</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">-</span><span class="mi">9223372036854775808</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">typemin</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span>
<span class="n">true</span>
</pre></div>
</div>
<p>위와 같기 때문에, Julia 정수의 연산은 사실
<a class="reference external" href="https://en.wikipedia.org/wiki/Modular_arithmetic">나머지 연산</a>임을
알 수 있다.
오버플로우가 나올 수 있는 프로그램에서는,
오버플로우를 명시적으로 체크하는 것이 필수적이다;
그런 경우가 아니라면
<a class="reference internal" href="#man-arbitrary-precision-arithmetic"><em>임의 정밀도 연산</em></a>에서 <tt class="docutils literal"><span class="pre">BigInt</span></tt>타입을
사용하는 것을 추천한다.</p>
</div>
<div class="section" id="id4">
<h3>나눗셈 관련 에러들<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>정수의 나눗셈 연산 (<tt class="docutils literal"><span class="pre">div</span></tt> 함수)는 두 가지 예외적인 경우가 있다;
0으로 나누기, 그리고 컴퓨터가 표현할 수 있는 최소의 음의 정수값을
-1로 나누는 것이다.
두 가지 경우 모두 <tt class="xref jl jl-exc docutils literal"><span class="pre">DivideError</span></tt>를 유발한다.
두 <cite>나머지</cite> 연산 함수(remainder 와 modulus, <tt class="docutils literal"><span class="pre">rem</span></tt>와 <tt class="docutils literal"><span class="pre">mod</span></tt>)는
두번째 매개변수가 0일 때 <tt class="xref jl jl-exc docutils literal"><span class="pre">DivideError</span></tt>를 던진다(throw).</p>
</div>
</div>
<div class="section" id="id5">
<h2>부동소수점으로 표현되는 실수<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>부동소수점 리터럴은 표준 포맷을 이용하여 표현된다.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mf">1.0</span>
<span class="mf">1.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">1.</span>
<span class="mf">1.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">0.5</span>
<span class="mf">0.5</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="o">.</span><span class="mi">5</span>
<span class="mf">0.5</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="o">-</span><span class="mf">1.23</span>
<span class="o">-</span><span class="mf">1.23</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">1e10</span>
<span class="mf">1.0e10</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">2.5e-4</span>
<span class="mf">0.00025</span>
</pre></div>
</div>
<p>위에 나온 결과는 모두 <tt class="docutils literal"><span class="pre">Float64</span></tt> 타입의 값들이다.
<tt class="docutils literal"><span class="pre">Float32</span></tt> 값들은 <tt class="docutils literal"><span class="pre">e</span></tt> 대신에 <tt class="docutils literal"><span class="pre">f</span></tt>를 쓰면 입력할 수 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mf">0.5f0</span>
<span class="mf">0.5f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="kt">Float32</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">2.5f-4</span>
<span class="mf">0.00025f0</span>
</pre></div>
</div>
<p>값들은 쉽게 <tt class="docutils literal"><span class="pre">Float32</span></tt> 타입으로 변환할 수 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Float32</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span>
<span class="o">-</span><span class="mf">1.5f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="kt">Float32</span>
</pre></div>
</div>
<p>16진수로 표현되는 부동소수점 리터럴은 유효하지만,
<tt class="docutils literal"><span class="pre">Float64</span></tt> 타입에서만 가능하다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mh">0x1</span><span class="n">p0</span>
<span class="mf">1.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mh">0x1</span><span class="o">.</span><span class="mi">8</span><span class="n">p3</span>
<span class="mf">12.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">0</span><span class="n">x</span><span class="o">.</span><span class="mi">4</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span>
<span class="mf">0.125</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="kt">Float64</span>
</pre></div>
</div>
<p>16비트의 정밀도를 가지는 반정도 부동소수점도 지원된다. (<tt class="docutils literal"><span class="pre">Float16</span></tt>)
하지만 메모리에 저장할 때만 쓰이고 계산할 때는 자동으로
<tt class="docutils literal"><span class="pre">Float32</span></tt>로 변환된다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">sizeof</span><span class="p">(</span><span class="n">Float16</span><span class="p">(</span><span class="mf">4.</span><span class="p">))</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">Float16</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span>
<span class="mf">8.0f0</span>
</pre></div>
</div>
<p>밑줄 <tt class="docutils literal"><span class="pre">_</span></tt>는 수 구분자로 쓰일 수 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mi">10_000</span><span class="p">,</span> <span class="mf">0.000_000_005</span><span class="p">,</span> <span class="mh">0xdead_beef</span><span class="p">,</span> <span class="mb">0b1011_0010</span>
<span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mf">5.0e-9</span><span class="p">,</span><span class="mh">0xdeadbeef</span><span class="p">,</span><span class="mh">0xb2</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="id6">
<h3>실수로서의 숫자 0<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>부동소수점은 양수 0과 음수 0으로 불리우는
<a class="reference external" href="https://en.wikipedia.org/wiki/Signed_zero">두 개의 0</a>을
가진다. 그 둘은 값은 0으로써 같지만,
다음과 같이 <tt class="docutils literal"><span class="pre">bits</span></tt> 함수를 이용하면 알 수 있듯이,
바이너리로 표기했을 때 다르다는 것을 알 수 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mf">0.0</span> <span class="o">==</span> <span class="o">-</span><span class="mf">0.0</span>
<span class="n">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="s">&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">(</span><span class="o">-</span><span class="mf">0.0</span><span class="p">)</span>
<span class="s">&quot;1000000000000000000000000000000000000000000000000000000000000000&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="man-special-floats">
<span id="id8"></span><h3>특별한 부동소수점 값들<a class="headerlink" href="#man-special-floats" title="Permalink to this headline">¶</a></h3>
<p>다음은 실수에는 포함되지는 않은
세 종류의 특정 표준 부동소수점이 있다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="15%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="3">특별한 값</th>
<th class="head">이름</th>
<th class="head">설명</th>
</tr>
<tr class="row-even"><th class="head"><tt class="docutils literal"><span class="pre">Float16</span></tt></th>
<th class="head"><tt class="docutils literal"><span class="pre">Float32</span></tt></th>
<th class="head"><tt class="docutils literal"><span class="pre">Float64</span></tt></th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">Inf16</span></tt></td>
<td><tt class="docutils literal"><span class="pre">Inf32</span></tt></td>
<td><tt class="docutils literal"><span class="pre">Inf</span></tt></td>
<td>positive infinity</td>
<td>모든 유한한 부동소수점 실수보다 큰 값</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">-Inf16</span></tt></td>
<td><tt class="docutils literal"><span class="pre">-Inf32</span></tt></td>
<td><tt class="docutils literal"><span class="pre">-Inf</span></tt></td>
<td>negative infinity</td>
<td>모든 유한한 부동소수점 실수보다 작은 값</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">NaN16</span></tt></td>
<td><tt class="docutils literal"><span class="pre">NaN32</span></tt></td>
<td><tt class="docutils literal"><span class="pre">NaN</span></tt></td>
<td>not a number</td>
<td>어떠한 부동소수점 실수와도 같지 않은 값 (자기 자신 포함)</td>
</tr>
</tbody>
</table>
<p>이와 같은 유한하지 않은 부동소수점 값들이
서로와 다른 실수에 대해서 순서를 매길 때에는,
<a class="reference internal" href="mathematical-operations.html#man-numeric-comparisons"><em>수치 비교</em></a>를 참고하길 바란다.
<a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 standard</a>에 따르면,
위에서의 부동소수점 실수들은 어떤 산술 연산에 의한 결과임을 알 수 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="nb">Inf</span>
<span class="mf">0.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="nb">Inf</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="o">-</span><span class="mi">5</span><span class="o">/</span><span class="mi">0</span>
<span class="o">-</span><span class="nb">Inf</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">0.000001</span><span class="o">/</span><span class="mi">0</span>
<span class="nb">Inf</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">0</span><span class="o">/</span><span class="mi">0</span>
<span class="n">NaN</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">500</span> <span class="o">+</span> <span class="nb">Inf</span>
<span class="nb">Inf</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">500</span> <span class="o">-</span> <span class="nb">Inf</span>
<span class="o">-</span><span class="nb">Inf</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">Inf</span> <span class="o">+</span> <span class="nb">Inf</span>
<span class="nb">Inf</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">Inf</span> <span class="o">-</span> <span class="nb">Inf</span>
<span class="n">NaN</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">Inf</span> <span class="o">*</span> <span class="nb">Inf</span>
<span class="nb">Inf</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">Inf</span> <span class="o">/</span> <span class="nb">Inf</span>
<span class="n">NaN</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">0</span> <span class="o">*</span> <span class="nb">Inf</span>
<span class="n">NaN</span>
</pre></div>
</div>
<p><tt class="xref jl jl-func docutils literal"><span class="pre">typemin()</span></tt>과 <tt class="xref jl jl-func docutils literal"><span class="pre">typemax()</span></tt> 함수는
부동소수점 타입에도 적용이 가능하다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="n">Float16</span><span class="p">),</span><span class="nb">typemax</span><span class="p">(</span><span class="n">Float16</span><span class="p">))</span>
<span class="p">(</span><span class="o">-</span><span class="n">Inf16</span><span class="p">,</span><span class="n">Inf16</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Float32</span><span class="p">),</span><span class="nb">typemax</span><span class="p">(</span><span class="kt">Float32</span><span class="p">))</span>
<span class="p">(</span><span class="o">-</span><span class="n">Inf32</span><span class="p">,</span><span class="n">Inf32</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Float64</span><span class="p">),</span><span class="nb">typemax</span><span class="p">(</span><span class="kt">Float64</span><span class="p">))</span>
<span class="p">(</span><span class="o">-</span><span class="nb">Inf</span><span class="p">,</span><span class="nb">Inf</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="machine-epsilon">
<h3>계산기 입실론(Machine epsilon)<a class="headerlink" href="#machine-epsilon" title="Permalink to this headline">¶</a></h3>
<p>대부분의 실수들은 부동소수점 형태로는 정확하게 표현할 수 없다.
그리고 현재로서는 많은 경우 두 인접한 부동소수점으로 표현 가능한 실수가
얼만큼 떨어져 있는 지 알 필요가 있다.
따라서 이를 위해 계산기 입실론(machine epsilon)이라는 개념이 도입하게 되었다.</p>
<p>Julia는 <tt class="xref jl jl-func docutils literal"><span class="pre">eps()</span></tt>라는 것을 제공한다.
이는 표현 가능한 부동소수점 실수 중에서 <tt class="docutils literal"><span class="pre">1.0</span></tt> 과
<tt class="docutils literal"><span class="pre">1.0</span></tt>보다 크면서 <tt class="docutils literal"><span class="pre">1.0</span></tt>의 옆에 있는 값과의 거리를 말한다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">eps</span><span class="p">(</span><span class="kt">Float32</span><span class="p">)</span>
<span class="mf">1.1920929f-7</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">eps</span><span class="p">(</span><span class="kt">Float64</span><span class="p">)</span>
<span class="mf">2.220446049250313e-16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">eps</span><span class="p">()</span> <span class="c"># same as eps(Float64)</span>
<span class="mf">2.220446049250313e-16</span>
</pre></div>
</div>
<p>위 코드에서 나오는 <tt class="docutils literal"><span class="pre">eps</span></tt> 값들은
<tt class="docutils literal"><span class="pre">Float32</span></tt>와 <tt class="docutils literal"><span class="pre">Float64</span></tt> 값 중에서 바이너리로 표기했을 때
<tt class="docutils literal"><span class="pre">2.0^-23</span></tt> 과 <tt class="docutils literal"><span class="pre">2.0^-52</span></tt>를 각각 나타낸다.
<tt class="xref jl jl-func docutils literal"><span class="pre">eps()</span></tt> 함수는 부동소수점 실수를 매개변수로 받을 수도 있는데,
이 때는 <tt class="docutils literal"><span class="pre">1.0</span></tt>이 아니라 주어진 값과 주어진 값 바로 옆에서
주어진 값과의 거리를 반환한다.
그 말은 <tt class="docutils literal"><span class="pre">eps(x)</span></tt>의 반환값은 <tt class="docutils literal"><span class="pre">x</span></tt>와 같은 타입이고,
<tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">eps(x)</span></tt>는 <tt class="docutils literal"><span class="pre">x</span></tt>보다 큰 <tt class="docutils literal"><span class="pre">x</span></tt> 바로 옆에 있는
표현 가능한 부동소수점 실수를 뜻한다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="nb">eps</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="mf">2.220446049250313e-16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">eps</span><span class="p">(</span><span class="mf">1000.</span><span class="p">)</span>
<span class="mf">1.1368683772161603e-13</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">eps</span><span class="p">(</span><span class="mf">1e-27</span><span class="p">)</span>
<span class="mf">1.793662034335766e-43</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">eps</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="mf">5.0e-324</span>
</pre></div>
</div>
<p>두 인접하면서 표현 가능한 부동소수점 실수들은 상수가 아니지만,
작은 값에서는 작은 값을 지니고, 큰 값들에서는 큰 값을 나타낸다.
다른 말로 말하면, 표현 가능한 부동소수점 실수들은 실수축 상에서
0에 근접할 때 가장 밀집되어있고, 0에서 멀어질수록 점점 드물다.
정의에 의하면, <tt class="docutils literal"><span class="pre">eps(1.0)</span></tt>은 <tt class="docutils literal"><span class="pre">eps(Float64)</span></tt>와 같은데, 그 이유는
<tt class="docutils literal"><span class="pre">1.0</span></tt>은 64비트 부동소수점 실수이기 때문이다.</p>
<p>또한 Julia는 <tt class="xref jl jl-func docutils literal"><span class="pre">nextfloat()</span></tt>과 <tt class="xref jl jl-func docutils literal"><span class="pre">prevfloat()</span></tt> 함수를 제공하는데 이는,
표현 가능한 부동소수점 실수 중에서 주어진 실수 바로 옆에 있는
크거나 작은 수를 반환한다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">1.25f0</span>
<span class="mf">1.25f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">nextfloat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="mf">1.2500001f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">prevfloat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="mf">1.2499999f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">(</span><span class="n">prevfloat</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="s">&quot;00111111100111111111111111111111&quot;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="s">&quot;00111111101000000000000000000000&quot;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">(</span><span class="n">nextfloat</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="s">&quot;00111111101000000000000000000001&quot;</span>
</pre></div>
</div>
<p>위의 예제는 서로 이웃한 표현 가능한 부동소수점 수는
바이너리 정수 표기법을 가질 수 있다는 기본적인 원리를 새삼 일깨워 준다.</p>
</div>
<div class="section" id="id9">
<h3>반올림 모드<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>만약 어떤 숫자가 정확한 부동소수점 표현을 가지고 있지 않다면,
그 수는 반드시 어떤 표현 가능한 값으로 반올림되어야 한다.
그러나, 만약 사용자가 원한다면,
<a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 standard</a>에
따라 반올림 방식에 대해서는 변경할 수 있다.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mf">1.1</span> <span class="o">+</span> <span class="mf">0.1</span>
<span class="mf">1.2000000000000002</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">setrounding</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="n">RoundDown</span><span class="p">)</span> <span class="k">do</span>
       <span class="mf">1.1</span> <span class="o">+</span> <span class="mf">0.1</span>
       <span class="k">end</span>
<span class="mf">1.2</span>
</pre></div>
</div>
<p>기본 반올림 모드는 항상 <tt class="xref jl jl-const docutils literal"><span class="pre">RoundNearest</span></tt>이다.
이는 가장 근접한 표현 가능한 값으로 반올림하되,
만약 두 표현 가능한 값 중간에 주어진 값이 걸쳐 있으면
가수부 값 중 짝수(바이너리이므로 0)로 반올림 하는 모드이다.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">반올림은 일반적으로 기본 산술 함수
(<tt class="xref jl jl-func docutils literal"><span class="pre">+()</span></tt>, <tt class="xref jl jl-func docutils literal"><span class="pre">-()</span></tt>, <tt class="xref jl jl-func docutils literal"><span class="pre">*()</span></tt>, <tt class="xref jl jl-func docutils literal"><span class="pre">/()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></tt>)와
타입 변환 연산에서만 정확하다. 많은 다른 함수들은
기본 값인 <tt class="xref jl jl-const docutils literal"><span class="pre">RoundNearest</span></tt>를 가정하고 짜여져 있고,
이는 다른 반올림 모드에서는 부정확한 값을 제공할 수 있다.</p>
</div>
</div>
<div class="section" id="id11">
<h3>부동소수점 실수에 대해서 더 읽으면 좋은 문서들<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>부동소수점 연산은 많은 미묘한 것들을 수반하고 있기 때문에
저수준(low-level) 구현에 익숙하지 않은 유저들은 당황할 수도 있다.
그러나 그 미묘한 점들은 과학적 연산과 관련된 많은 책들에서 잘 설명되고 있고,
아래에 나열하는 참고문헌도 참고하면 좋을 것이다:</p>
<ul class="simple">
<li>부동소수점과 관련해서 가장 확실한 가이드는 <a class="reference external" href="http://standards.ieee.org/findstds/standard/754-2008.html">IEEE 754-2008
Standard</a>이지만, 유료이다.</li>
<li>부동소수점이 어떻게 표현되는지에 대한 간략하면서도 명쾌한 설명은
John D. Cook의 <a class="reference external" href="http://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/">블로그 글</a>을 참고하면 된다. 같은 주제에 관하여 이와 더불어서 그의
<a class="reference external" href="http://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/">소개글</a>글은 부동소수점이 실수의 이상적인 추상화와 다름으로써 생기는
몇 가지 문제에 대해서도 다루고 있다.</li>
<li>Bruce Dawson의 <a class="reference external" href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/">series of blog posts on floating-point
numbers</a>도
추천하는 바이다.</li>
<li>상급자들은 부동소수점의 내부 구현에 관한 이야기들과
부동소수점 연산을 할 때 맞닥뜨릴 수 있는 수치적인 정확도에 관한 문제들에
대해서는 David Goldberg의 논문, <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;rep=rep1&amp;type=pdf">What Every Computer Scientist Should Know About Floating-Point
Arithmetic</a>을
참고하는 것이 좋다.</li>
<li>부동소수점에 관한 역사, 근원, 몇 가지 이슈들 뿐만 아니라 수치 해석과 관련한
많은 다양한 이야기들에 대한 자세한 문서를 얻고 싶다면
<a class="reference external" href="https://en.wikipedia.org/wiki/William_Kahan">William Kahan</a>가 작성한
<a class="reference external" href="http://www.cs.berkeley.edu/~wkahan/">collected writings</a>을 참고하는 것을 추천한다.
이 문서는 &#8220;부동소수점의 아버지(Father of Floating-Point)&#8221;라고도 알려져 있다.</li>
<li>특별히 부동소수점의 역사에 관해서 관심이 더 생긴다면,
<a class="reference external" href="http://www.cs.berkeley.edu/~wkahan/ieee754status/754story.html">An Interview with the Old
Man of Floating-Point</a>을
읽기를 바란다.</li>
</ul>
</div>
</div>
<div class="section" id="man-arbitrary-precision-arithmetic">
<span id="id14"></span><h2>임의 정밀도 연산<a class="headerlink" href="#man-arbitrary-precision-arithmetic" title="Permalink to this headline">¶</a></h2>
<p>임의 정밀도의 정수와 부동소수점들의 연산을 위해, Julia는
<a class="reference external" href="https://gmplib.org">GNU Multiple Precision Arithmetic Library (GMP)</a>와
<a class="reference external" href="http://www.mpfr.org">GNU MPFR Library</a>을 각각 래핑(wrapping)하였다
<tt class="xref jl jl-class docutils literal"><span class="pre">BigInt</span></tt>와 <tt class="xref jl jl-class docutils literal"><span class="pre">BigFloat</span></tt> 타입은 Julia에서
각각 임의 정밀도의 정수와 부동소수점을 다루기 위해 사용되고 있다.</p>
<p>기본 수치 타입으로부터 임의 정밀도 정수와 부동소수점 타입을 만들기 위해
생성자가 존재하며, <tt class="xref jl jl-func docutils literal"><span class="pre">parse()</span></tt>는 <tt class="xref jl jl-class docutils literal"><span class="pre">AbstractString</span></tt>들로부터
임의 정밀도 타입을 만들 수 있게 해준다.
한번 임의 정밀도 타입이 만들어지면,
<a class="reference internal" href="conversion-and-promotion.html#man-conversion-and-promotion"><em>type promotion and conversion mechanism</em></a>
덕분에 자유롭게 다른 수치타입과 연산을 수행할 수 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">BigInt</span><span class="p">(</span><span class="nb">typemax</span><span class="p">(</span><span class="kt">Int64</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">9223372036854775808</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">parse</span><span class="p">(</span><span class="n">BigInt</span><span class="p">,</span> <span class="s">&quot;123456789012345678901234567890&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">123456789012345678901234567891</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">parse</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span> <span class="s">&quot;1.23456789012345678901&quot;</span><span class="p">)</span>
<span class="mf">1.234567890123456789010000000000000000000000000000000000000000000000000000000004</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">BigFloat</span><span class="p">(</span><span class="mf">2.0</span><span class="o">^</span><span class="mi">66</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
<span class="mf">2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">factorial</span><span class="p">(</span><span class="n">BigInt</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
<span class="mi">815915283247897734345611269596115894272000000000</span>
</pre></div>
</div>
<p>그러나, 기본 타입과 <tt class="xref jl jl-class docutils literal"><span class="pre">BigInt</span></tt>/<tt class="xref jl jl-class docutils literal"><span class="pre">BigFloat</span></tt> 간의
묵시적 형 변환(type promotion)은 자동으로 이루어지지 않고,
반드시 명시적으로 처리되어야 한다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">typemin</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span>
<span class="o">-</span><span class="mi">9223372036854775808</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
<span class="mi">9223372036854775807</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="kt">Int64</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">BigInt</span><span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Int64</span><span class="p">))</span>
<span class="o">-</span><span class="mi">9223372036854775808</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
<span class="o">-</span><span class="mi">9223372036854775809</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nb">typeof</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="n">BigInt</span>
</pre></div>
</div>
<p><tt class="xref jl jl-class docutils literal"><span class="pre">BigFloat</span></tt> 타입에서 기본 정밀도(가수부의 비트수)와 반올림 모드는
<tt class="xref jl jl-func docutils literal"><span class="pre">setprecision()</span></tt>와 <tt class="xref jl jl-func docutils literal"><span class="pre">setrounding()</span></tt>를 호출함으로써
변경할 수 있으며, 한 번 호출된 이후에는 그 설정이 계속 유지된다.
특정 블럭의 코드에서만 정밀도와 반올림을 변경하기 위해서는
<tt class="docutils literal"><span class="pre">do</span></tt> 블럭의 코드에서와 같은 함수를 호출한다:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">setrounding</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span> <span class="n">RoundUp</span><span class="p">)</span> <span class="k">do</span>
       <span class="n">BigFloat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">parse</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span> <span class="s">&quot;0.1&quot;</span><span class="p">)</span>
       <span class="k">end</span>
<span class="mf">1.100000000000000000000000000000000000000000000000000000000000000000000000000003</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">setrounding</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span> <span class="n">RoundDown</span><span class="p">)</span> <span class="k">do</span>
       <span class="n">BigFloat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">parse</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span> <span class="s">&quot;0.1&quot;</span><span class="p">)</span>
       <span class="k">end</span>
<span class="mf">1.099999999999999999999999999999999999999999999999999999999999999999999999999986</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">setprecision</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span> <span class="k">do</span>
       <span class="n">BigFloat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">parse</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span> <span class="s">&quot;0.1&quot;</span><span class="p">)</span>
       <span class="k">end</span>
<span class="mf">1.1000000000004</span>
</pre></div>
</div>
</div>
<div class="section" id="man-numeric-literal-coefficients">
<span id="id15"></span><h2>수치형 리터럴 계수<a class="headerlink" href="#man-numeric-literal-coefficients" title="Permalink to this headline">¶</a></h2>
<p>보통의 수학 식과 표현식을 깔끔하게 표현하기 위해서,
Julia는 변수가 수치형 리터럴 바로 다음에 있으면,
둘 사이의 관계가 곱셈임을 가정한다.
이는 다항식의 표현을 더욱 깔끔하게 만든다:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mi">2</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">10</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="mf">1.5</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mf">13.0</span>
</pre></div>
</div>
<p>이는 지수함수의 포현도 매우 아름답게 만들 수 있다:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span><span class="n">x</span>
<span class="mi">64</span>
</pre></div>
</div>
<p>수치형 리터럴 계수의 선행(precedence)도
부정연산과 같은 단항 연산과 같이 작동한다.
따라서 <tt class="docutils literal"><span class="pre">2^3x</span></tt>는 <tt class="docutils literal"><span class="pre">2^(3x)</span></tt>로,
<tt class="docutils literal"><span class="pre">2x^3</span></tt>은 <tt class="docutils literal"><span class="pre">2*(x^3)</span></tt>으로 파싱(parsing)된다.</p>
<p>수치형 리터럴은 괄호가 있는 식에서도 계수(coefficients)로 작동할 수 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="mi">2</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>게다가 괄호 표현식은 변수 또한 계수로 생각하여,
곱셈기호 없이도 변수들 간의 곱으로 식을 표현할 수도 있다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="n">x</span>
<span class="mi">6</span>
</pre></div>
</div>
<p>그러나 두 괄호식을 병치하거나 괄호식 앞에 변수를 두는 경우는
계수로 사용할 수 없다.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">MethodError</span><span class="p">:</span> <span class="sb">`Int64`</span> <span class="n">has</span> <span class="n">no</span> <span class="n">method</span> <span class="n">matching</span> <span class="kt">Int64</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ERROR</span><span class="p">:</span> <span class="n">MethodError</span><span class="p">:</span> <span class="sb">`Int64`</span> <span class="n">has</span> <span class="n">no</span> <span class="n">method</span> <span class="n">matching</span> <span class="kt">Int64</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">)</span>
</pre></div>
</div>
<p>두 표현식은 함수로써 인식된다: 괄호앞에 붙는 수치형 리터럴이 아닌
표현식들은 모두 함수와 함수의 매개변수로 인식된다.
(자세한 설명을 위해서는 <a class="reference internal" href="functions.html#man-functions"><em>Functions</em></a>를 참고하도록 하자)
그래서 두 가지 경우 모두 왼쪽에 있는 값이
함수가 아님을 알려주는 에러가 발생한다.</p>
<p>위에서 언급한 문법적 강화효과는 수학식을 작성할 때 생기는 시각적 공해를
줄일 수 있도록 해준다. 단지 한 가지 알아야 할 점은
수치형 계수와 이에 곱해지는 변수 혹은 괄호식등 사이에는
빈칸이 있어서는 안된다.</p>
<div class="section" id="id16">
<h3>문법적 충돌<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>리터럴 계수를 병치하는 문법은
16진수 정수 리터럴과 부동소수점의 공학적 표현라는
두 수치형 리터럴 문법과 충돌이 생길 수 있다
다음은 문법적 충돌이 발생하는 예이다.</p>
<p>16진수 리터럴 표현식 <tt class="docutils literal"><span class="pre">0xff</span></tt>는 수치형 리터럴 <tt class="docutils literal"><span class="pre">0</span></tt>과 변수 <tt class="docutils literal"><span class="pre">xff</span></tt>의
곱셈으로 해석될 수 있다.
부동소수점 리터럴 표현식 <tt class="docutils literal"><span class="pre">1e10</span></tt>은 수치형 리터럴 <tt class="docutils literal"><span class="pre">1</span></tt>이
변수 <tt class="docutils literal"><span class="pre">e10</span></tt>에 곱해지는 걸로 해석될 수 있고 이는 <tt class="docutils literal"><span class="pre">e</span></tt>가 아닌,
<tt class="docutils literal"><span class="pre">E</span></tt>를 쓸 때에도 마찬가지이다.</p>
<p>이 두 가지 경우에, 우리는 수치형 리터럴을 해석하는데 있어서
다음과 같은 방식으로 모호함을 해결했다.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">0x</span></tt>로 시작하는 표현식은 항상 16진수 리터럴이다.</li>
<li>수치형 리터럴으로 시작하는 표현식에서 수치형 리터럴 다음에 <tt class="docutils literal"><span class="pre">e</span></tt> 혹은
<tt class="docutils literal"><span class="pre">E</span></tt>가 뒤따라오면 항상 부동소수점 리터럴이다.</li>
</ul>
</div>
</div>
<div class="section" id="id17">
<h2>리터럴 0와 1<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>Julia는 어떤 특정한 타입이나 주어진 변수의 타입에 따라 리터럴 0이나 1을
리턴하는 함수를 제공한다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">함수</th>
<th class="head">설명</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="xref jl jl-func docutils literal"><span class="pre">zero(x)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">x</span></tt> 타입이나 변수 <tt class="docutils literal"><span class="pre">x</span></tt>의 타입의 리터럴 0</td>
</tr>
<tr class="row-odd"><td><tt class="xref jl jl-func docutils literal"><span class="pre">one(x)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">x</span></tt> 타입이나 변수 <tt class="docutils literal"><span class="pre">x</span></tt>의 타입의 리터럴 1</td>
</tr>
</tbody>
</table>
<p>위 함수들은 <a class="reference internal" href="mathematical-operations.html#man-numeric-comparisons"><em>수치 비교</em></a>에서
불필요한 <a class="reference internal" href="conversion-and-promotion.html#man-conversion-and-promotion"><em>type conversion</em></a>에
의한 성능저하를 줄일 때 유용하다.</p>
<p>예제:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">julia</span><span class="o">&gt;</span> <span class="n">zero</span><span class="p">(</span><span class="kt">Float32</span><span class="p">)</span>
<span class="mf">0.0f0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">zero</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="mf">0.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">one</span><span class="p">(</span><span class="kt">Int32</span><span class="p">)</span>
<span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">one</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">)</span>
<span class="mf">1.000000000000000000000000000000000000000000000000000000000000000000000000000000</span>
</pre></div>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mathematical-operations.html" class="btn btn-neutral float-right" title="수학 연산들과 기본적인 함수들" accesskey="n"> 다음 <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="variables.html" class="btn btn-neutral" title="변수" accesskey="p"><span class="fa fa-arrow-circle-left"></span> 이전 </a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on Apr 07, 2016.
    </p>
  </div>

</footer>


<div
  class="fb-like"
  data-share="true"
  data-width="450"
  data-show-faces="true">
</div>

<script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '685509058259607',
      xfbml      : true,
      version    : 'v2.3'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "https://connect.facebook.net/ko_KR/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-width="100%" data-version="v2.3"></div>

        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'X.Y.Z-unknown',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   


<script type="text/javascript" src="../_static/jquery.word-break-keep-all.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('p').wordBreakKeepAll();
});
</script>

<script type="text/javascript" src="../_static/blame.js"></script>

</body>
</html>