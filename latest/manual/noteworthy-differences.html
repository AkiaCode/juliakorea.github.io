

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="fb:app_id" content="685509058259607" />

  
  <title>Noteworthy Differences from other Languages</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/julia.css" type="text/css" />
  
    <link rel="top" title="None" href="../index.html"/>
        <link rel="next" title="Unicode Input" href="unicode-input.html"/>
        <link rel="prev" title="Frequently Asked Questions" href="faq.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="../_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="../index.html" class="fa fa-home"> Julia Language</a>
        -->
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">소개 글</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">시작하기</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting-started.html#id2">다른 읽을 거리</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="variables.html">변수</a><ul>
<li class="toctree-l2"><a class="reference internal" href="variables.html#id2">변수명의 허용범위</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables.html#id3">코딩 컨벤션</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="integers-and-floating-point-numbers.html">정수와 부동소수점으로 표현되는 실수</a><ul>
<li class="toctree-l2"><a class="reference internal" href="integers-and-floating-point-numbers.html#id2">정수</a></li>
<li class="toctree-l2"><a class="reference internal" href="integers-and-floating-point-numbers.html#id5">부동소수점으로 표현되는 실수</a></li>
<li class="toctree-l2"><a class="reference internal" href="integers-and-floating-point-numbers.html#man-arbitrary-precision-arithmetic">임의 정밀도 연산</a></li>
<li class="toctree-l2"><a class="reference internal" href="integers-and-floating-point-numbers.html#man-numeric-literal-coefficients">수치형 리터럴 계수</a></li>
<li class="toctree-l2"><a class="reference internal" href="integers-and-floating-point-numbers.html#id17">리터럴 0와 1</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mathematical-operations.html">수학 연산들과 기본적인 함수들</a><ul>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#id2">산술 연산자</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#id3">비트 연산자</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#id4">갱신 연산자</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#man-numeric-comparisons">수치 비교</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#man-numerical-conversions">수치 변환</a></li>
<li class="toctree-l2"><a class="reference internal" href="mathematical-operations.html#man-elementary-functions">기초 함수</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="complex-and-rational-numbers.html">복소수와 유리수</a><ul>
<li class="toctree-l2"><a class="reference internal" href="complex-and-rational-numbers.html#man-complex-numbers">복소수</a></li>
<li class="toctree-l2"><a class="reference internal" href="complex-and-rational-numbers.html#man-rational-numbers">유리수</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="strings.html">Strings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="strings.html#characters">Characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#string-basics">String Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#unicode-and-utf-8">Unicode and UTF-8</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#triple-quoted-string-literals">Triple-Quoted String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#common-operations">Common Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#regular-expressions">Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#id3">Byte Array Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html#version-number-literals">Version Number Literals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="functions.html#argument-passing-behavior">Argument Passing Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#the-return-keyword">The <tt class="docutils literal"><span class="pre">return</span></tt> Keyword</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#operators-are-functions">Operators Are Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#operators-with-special-names">Operators With Special Names</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#anonymous-functions">Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#multiple-return-values">Multiple Return Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#varargs-functions">Varargs Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#optional-arguments">Optional Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#keyword-arguments">Keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html#further-reading">Further Reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="control-flow.html">Control Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#compound-expressions">Compound Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#conditional-evaluation">Conditional Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#short-circuit-evaluation">Short-Circuit Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#exception-handling">Exception Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="control-flow.html#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="variables-and-scoping.html">Scope of Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="variables-and-scoping.html#global-scope">Global Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables-and-scoping.html#local-scope">Local Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="variables-and-scoping.html#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="types.html#type-declarations">Type Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#abstract-types">Abstract Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#bits-types">Bits Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#composite-types">Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#immutable-composite-types">Immutable Composite Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#declared-types">Declared Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#type-unions">Type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#man-parametric-types">Parametric Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#type-aliases">Type Aliases</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#operations-on-types">Operations on Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#value-types">&#8220;Value types&#8221;</a></li>
<li class="toctree-l2"><a class="reference internal" href="types.html#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="methods.html">Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="methods.html#defining-methods">Defining Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#method-ambiguities">Method Ambiguities</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#parametric-methods">Parametric Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#function-like-objects">Function-like objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="methods.html#empty-generic-functions">Empty generic functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="constructors.html">Constructors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#outer-constructor-methods">Outer Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#inner-constructor-methods">Inner Constructor Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#incomplete-initialization">Incomplete Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#parametric-constructors">Parametric Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#case-study-rational">Case Study: Rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#constructors-and-conversion">Constructors and Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="constructors.html#outer-only-constructors">Outer-only constructors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="conversion-and-promotion.html">Conversion and Promotion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="conversion-and-promotion.html#conversion">Conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="conversion-and-promotion.html#promotion">Promotion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interfaces.html">Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="interfaces.html#iteration">Iteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="interfaces.html#indexing">Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="interfaces.html#abstract-arrays">Abstract Arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="modules.html#summary-of-module-usage">Summary of module usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#accessing-documentation">Accessing Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#functions-methods">Functions &amp; Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#advanced-usage">Advanced Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#syntax-guide">Syntax Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="documentation.html#markdown-syntax-notes">Markdown Syntax Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="metaprogramming.html">Metaprogramming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#program-representation">Program representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#expressions-and-evaluation">Expressions and evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#code-generation">Code Generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#non-standard-string-literals">Non-Standard String Literals</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaprogramming.html#generated-functions">Generated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="arrays.html">Multi-dimensional Arrays</a><ul>
<li class="toctree-l2"><a class="reference internal" href="arrays.html#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="arrays.html#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="linear-algebra.html">Linear algebra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="linear-algebra.html#matrix-factorizations">Matrix factorizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="linear-algebra.html#special-matrices">Special matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="networking-and-streams.html">Networking and Streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#basic-stream-i-o">Basic Stream I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#text-i-o">Text I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#io-output-contextual-properties">IO Output Contextual Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#working-with-files">Working with Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#a-simple-tcp-example">A simple TCP example</a></li>
<li class="toctree-l2"><a class="reference internal" href="networking-and-streams.html#resolving-ip-addresses">Resolving IP Addresses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="parallel-computing.html">Parallel Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#data-movement">Data Movement</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#parallel-map-and-loops">Parallel Map and Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#synchronization-with-remote-references">Synchronization With Remote References</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#scheduling">Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#channels">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#remote-references-and-abstractchannels">Remote references and AbstractChannels</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#remote-references-and-distributed-garbage-collection">Remote References and Distributed Garbage Collection</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#id2">Shared Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#clustermanagers">ClusterManagers</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel-computing.html#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dates.html">Date and DateTime</a><ul>
<li class="toctree-l2"><a class="reference internal" href="dates.html#constructors">Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#durations-comparisons">Durations/Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#accessor-functions">Accessor Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#query-functions">Query Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#adjuster-functions">Adjuster Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="dates.html#period-types">Period Types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="running-external-programs.html">Running External Programs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="running-external-programs.html#interpolation">Interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="running-external-programs.html#quoting">Quoting</a></li>
<li class="toctree-l2"><a class="reference internal" href="running-external-programs.html#pipelines">Pipelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#mapping-c-types-to-julia">Mapping C Types to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#some-examples-of-c-wrappers">Some Examples of C Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#garbage-collection-safety">Garbage Collection Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#non-constant-function-specifications">Non-constant Function Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#indirect-calls">Indirect Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#accessing-global-variables">Accessing Global Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#thread-safety">Thread-safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#more-about-callbacks">More About Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="calling-c-and-fortran-code.html#handling-operating-system-variation">Handling Operating System Variation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interacting-with-julia.html">Interacting With Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="interacting-with-julia.html#the-different-prompt-modes">The different prompt modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="interacting-with-julia.html#key-bindings">Key bindings</a></li>
<li class="toctree-l2"><a class="reference internal" href="interacting-with-julia.html#tab-completion">Tab completion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="embedding.html">Embedding Julia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#high-level-embedding">High-Level Embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#converting-types">Converting Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#calling-julia-functions">Calling Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#memory-management">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#working-with-arrays">Working with Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="embedding.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="packages.html">Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="packages.html#package-status">Package Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#adding-and-removing-packages">Adding and Removing Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#offline-installation-of-packages">Offline Installation of Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#installing-unregistered-packages">Installing Unregistered Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#updating-packages">Updating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#checkout-pin-and-free">Checkout, Pin and Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#custom-metadata-repository">Custom METADATA Repository</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="packages.html#package-development">Package Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="packages.html#initial-setup">Initial Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#making-changes-to-an-existing-package">Making changes to an existing package</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#creating-a-new-package">Creating a new Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#fixing-package-requirements">Fixing Package Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html#man-package-requirements">Requirements Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="profile.html">Profiling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="profile.html#basic-usage">Basic usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile.html#accumulation-and-clearing">Accumulation and clearing</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile.html#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile.html#configuration">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="profile.html#memory-allocation-analysis">Memory allocation analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="stacktraces.html">Stack Traces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="stacktraces.html#viewing-a-stack-trace">Viewing a stack trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="stacktraces.html#extracting-useful-information">Extracting useful information</a></li>
<li class="toctree-l2"><a class="reference internal" href="stacktraces.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="stacktraces.html#comparison-with-backtrace">Comparison with <tt class="docutils literal"><span class="pre">backtrace()</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="performance-tips.html">Performance Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#avoid-global-variables">Avoid global variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <tt class="docutils literal"><span class="pre">&#64;time</span></tt> and pay attention to memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#tools">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#type-declarations">Type declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#write-type-stable-functions">Write &#8220;type-stable&#8221; functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#separate-kernel-functions">Separate kernel functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#pre-allocating-outputs">Pre-allocating outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#fix-deprecation-warnings">Fix deprecation warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#tweaks">Tweaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#performance-annotations">Performance Annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance-tips.html#code-warntype"><tt class="docutils literal"><span class="pre">&#64;code_warntype</span></tt></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="workflow-tips.html">Workflow Tips</a><ul>
<li class="toctree-l2"><a class="reference internal" href="workflow-tips.html#repl-based-workflow">REPL-based workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="workflow-tips.html#browser-based-workflow">Browser-based workflow</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#write-functions-not-just-scripts">Write functions, not just scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#append-to-names-of-functions-that-modify-their-arguments">Append <tt class="docutils literal"><span class="pre">!</span></tt> to names of functions that modify their arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-strange-type-unions">Avoid strange type Unions</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-elaborate-container-types">Avoid elaborate container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia&#8217;s <tt class="docutils literal"><span class="pre">base/</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-overuse-try-catch">Don&#8217;t overuse try-catch</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-parenthesize-conditions">Don&#8217;t parenthesize conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-overuse">Don&#8217;t overuse ...</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-use-unnecessary-static-parameters">Don&#8217;t use unnecessary static parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-overuse-macros">Don&#8217;t overuse macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-expose-unsafe-operations-at-the-interface-level">Don&#8217;t expose unsafe operations at the interface level</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#don-t-overload-methods-of-base-container-types">Don&#8217;t overload methods of base container types</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#be-careful-with-type-equality">Be careful with type equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#do-not-write-x-f-x">Do not write <tt class="docutils literal"><span class="pre">x-&gt;f(x)</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="style-guide.html#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="faq.html#sessions-and-the-repl">Sessions and the REPL</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#packages-and-modules">Packages and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#nothingness-and-missing-values">Nothingness and missing values</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#memory">Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li>
<li class="toctree-l2"><a class="reference internal" href="faq.html#julia-releases">Julia Releases</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Noteworthy Differences from other Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li>
<li class="toctree-l2"><a class="reference internal" href="#noteworthy-differences-from-r">Noteworthy differences from R</a></li>
<li class="toctree-l2"><a class="reference internal" href="#noteworthy-differences-from-python">Noteworthy differences from Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="unicode-input.html">Unicode Input</a></li>
</ul>
<ul class="simple">
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../devdocs/reflection.html">Reflection and introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devdocs/julia.html">Documentation of Julia&#8217;s Internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/init.html">Initialization of the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/eval.html">Eval of Julia code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/ast.html">Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/types.html">More about types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/object.html">Memory layout of Julia Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/functions.html">Julia Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/callconv.html">Calling Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/cartesian.html">Base.Cartesian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/meta.html">Talking to the compiler (the <tt class="docutils literal"><span class="pre">:meta</span></tt> mechanism)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/subarrays.html">SubArrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/sysimg.html">System Image Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/llvm.html">Working with LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/boundscheck.html">Bounds checking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../devdocs/C.html">Developing/debugging Julia&#8217;s C code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../phdthesis/chap6.html">결론</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../phdthesis/chap6.html#id2">성능</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phdthesis/chap6.html#id3">앞으로 할 작업들</a></li>
<li class="toctree-l2"><a class="reference internal" href="../phdthesis/chap6.html#id4">프로젝트 상황</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Julia Language</a>
      </nav>



      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Noteworthy Differences from other Languages</li>
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="#" onclick="blame('manual/noteworthy-differences')" rel="nofollow"> 원문 보기</a>
            
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="noteworthy-differences-from-other-languages">
<span id="man-noteworthy-differences"></span><h1>Noteworthy Differences from other Languages<a class="headerlink" href="#noteworthy-differences-from-other-languages" title="Permalink to this headline">¶</a></h1>
<div class="section" id="noteworthy-differences-from-matlab">
<h2>Noteworthy differences from MATLAB<a class="headerlink" href="#noteworthy-differences-from-matlab" title="Permalink to this headline">¶</a></h2>
<p>Although MATLAB users may find Julia&#8217;s syntax familiar, Julia is not a MATLAB
clone. There are major syntactic and functional differences. The following are
some noteworthy differences that may trip up Julia users accustomed to MATLAB:</p>
<ul class="simple">
<li>Julia arrays are indexed with square brackets, <tt class="docutils literal"><span class="pre">A[i,j]</span></tt>.</li>
<li>Julia arrays are assigned by reference. After <tt class="docutils literal"><span class="pre">A=B</span></tt>, changing elements of
<tt class="docutils literal"><span class="pre">B</span></tt> will modify <tt class="docutils literal"><span class="pre">A</span></tt> as well.</li>
<li>Julia values are passed and assigned by reference. If a function modifies an
array, the changes will be visible in the caller.</li>
<li>Julia does not automatically grow arrays in an assignment statement.
Whereas in MATLAB <tt class="docutils literal"><span class="pre">a(4)</span> <span class="pre">=</span> <span class="pre">3.2</span></tt> can create the array <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">3.2]</span></tt>
and <tt class="docutils literal"><span class="pre">a(5)</span> <span class="pre">=</span> <span class="pre">7</span></tt> can grow it into <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">3.2</span> <span class="pre">7]</span></tt>, the corresponding
Julia statement <tt class="docutils literal"><span class="pre">a[5]</span> <span class="pre">=</span> <span class="pre">7</span></tt> throws an error if the length of <tt class="docutils literal"><span class="pre">a</span></tt> is less
than 5 or if this statement is the first use of the identifier <tt class="docutils literal"><span class="pre">a</span></tt>.
Julia has <tt class="xref jl jl-func docutils literal"><span class="pre">push!()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">append!()</span></tt>, which grow <tt class="xref jl jl-obj docutils literal"><span class="pre">Vector</span></tt>s
much more efficiently than MATLAB&#8217;s <tt class="docutils literal"><span class="pre">a(end+1)</span> <span class="pre">=</span> <span class="pre">val</span></tt>.</li>
<li>The imaginary unit <tt class="docutils literal"><span class="pre">sqrt(-1)</span></tt> is represented in Julia as <tt class="xref jl jl-obj docutils literal"><span class="pre">im</span></tt>, not
<tt class="docutils literal"><span class="pre">i</span></tt> or <tt class="docutils literal"><span class="pre">j</span></tt> as in MATLAB.</li>
<li>In Julia, literal numbers without a decimal point (such as <tt class="docutils literal"><span class="pre">42</span></tt>) create
integers instead of floating point numbers. Arbitrarily large integer
literals are supported. As a result, some operations such as <tt class="docutils literal"><span class="pre">2^-1</span></tt> will
throw a domain error as the result is not an integer (see
<a class="reference internal" href="faq.html#man-domain-error"><em>the FAQ entry on domain errors</em></a> for details).</li>
<li>In Julia, multiple values are returned and assigned as tuples, e.g.
<tt class="docutils literal"><span class="pre">(a,</span> <span class="pre">b)</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">2)</span></tt> or <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></tt>. MATLAB&#8217;s <tt class="docutils literal"><span class="pre">nargout</span></tt>, which is
often used in MATLAB to do optional work based on the number of returned
values, does not exist in Julia. Instead, users can use optional and keyword
arguments to achieve similar capabilities.</li>
<li>Julia has true one-dimensional arrays. Column vectors are of size <tt class="docutils literal"><span class="pre">N</span></tt>, not
<tt class="docutils literal"><span class="pre">Nx1</span></tt>. For example, <tt class="xref jl jl-func docutils literal"><span class="pre">rand(N)</span></tt> makes a 1-dimensional array.</li>
<li>In Julia v0.3, concatenating scalars and arrays with the syntax <tt class="docutils literal"><span class="pre">[x,y,z]</span></tt>
concatenates in the first dimension (&#8220;vertically&#8221;). For concatenation in the
second dimension (&#8220;horizontally&#8221;), use spaces as in <tt class="docutils literal"><span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]</span></tt>. To
construct block matrices (concatenating in the first two dimensions),
the syntax <tt class="docutils literal"><span class="pre">[a</span> <span class="pre">b;</span> <span class="pre">c</span> <span class="pre">d]</span></tt> is used to avoid confusion. In Julia v0.4, the
concatenation syntax <tt class="docutils literal"><span class="pre">[x,</span> <span class="pre">[y,</span> <span class="pre">z]]</span></tt> is deprecated in favor of <tt class="docutils literal"><span class="pre">[x;</span> <span class="pre">[y,</span> <span class="pre">z]]</span></tt>.</li>
<li>In Julia, <tt class="docutils literal"><span class="pre">a:b</span></tt> and <tt class="docutils literal"><span class="pre">a:b:c</span></tt> construct <tt class="xref jl jl-obj docutils literal"><span class="pre">Range</span></tt> objects. To construct
a full vector like in MATLAB, use <tt class="xref jl jl-func docutils literal"><span class="pre">collect(a:b)</span></tt>. Generally,
there is no need to call <tt class="docutils literal"><span class="pre">collect</span></tt> though. <tt class="docutils literal"><span class="pre">Range</span></tt> will act like a normal
array in most cases but is more efficient because it lazily computes its
values. This pattern of creating specialized objects instead of full arrays
is used frequently, and is also seen in functions such as <tt class="xref jl jl-func docutils literal"><span class="pre">linspace</span></tt>, or with iterators such as <tt class="xref jl jl-func docutils literal"><span class="pre">enumerate</span></tt>, and
<tt class="xref jl jl-func docutils literal"><span class="pre">zip</span></tt>. The special objects can mostly be used as if they were
normal arrays.</li>
<li>Functions in Julia return values from their last expression or the <tt class="docutils literal"><span class="pre">return</span></tt>
keyword instead of listing the names of variables to return in the function
definition (see <a class="reference internal" href="functions.html#man-return-keyword"><em>The return Keyword</em></a> for details).</li>
<li>A Julia script may contain any number of functions, and all definitions will
be externally visible when the file is loaded. Function definitions can be
loaded from files outside the current working directory.</li>
<li>In Julia, reductions such as <tt class="xref jl jl-func docutils literal"><span class="pre">sum()</span></tt>, <tt class="xref jl jl-func docutils literal"><span class="pre">prod()</span></tt>, and <tt class="xref jl jl-func docutils literal"><span class="pre">max()</span></tt> are
performed over every element of an array when called with a single argument,
as in <tt class="docutils literal"><span class="pre">sum(A)</span></tt>, even if <tt class="docutils literal"><span class="pre">A</span></tt> has more than one dimension.</li>
<li>In Julia, functions such as <tt class="xref jl jl-func docutils literal"><span class="pre">sort()</span></tt> that operate column-wise by default
(<tt class="docutils literal"><span class="pre">sort(A)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">sort(A,1)</span></tt>) do not have special behavior for
<tt class="docutils literal"><span class="pre">1xN</span></tt> arrays; the argument is returned unmodified since it still performs
<tt class="docutils literal"><span class="pre">sort(A,1)</span></tt>. To sort a <tt class="docutils literal"><span class="pre">1xN</span></tt> matrix like a vector, use <tt class="docutils literal"><span class="pre">sort(A,2)</span></tt>.</li>
<li>In Julia, if <tt class="docutils literal"><span class="pre">A</span></tt> is a 2-dimensional array, <tt class="docutils literal"><span class="pre">fft(A)</span></tt> computes a 2D FFT. In
particular, it is not equivalent to <tt class="docutils literal"><span class="pre">fft(A,1)</span></tt>, which computes a 1D FFT
acting column-wise.</li>
<li>In Julia, parentheses must be used to call a function with zero arguments,
like in <tt class="xref jl jl-func docutils literal"><span class="pre">tic()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">toc()</span></tt>.</li>
<li>Julia discourages the used of semicolons to end statements. The results of
statements are not automatically printed (except at the interactive prompt),
and lines of code do not need to end with semicolons. <tt class="xref jl jl-func docutils literal"><span class="pre">println()</span></tt> or
<tt class="xref jl jl-func docutils literal"><span class="pre">&#64;printf()</span></tt> can be used to print specific output.</li>
<li>In Julia, if <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> are arrays, logical comparison operations like
<tt class="docutils literal"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">B</span></tt> do not return an array of booleans. Instead, use <tt class="docutils literal"><span class="pre">A</span> <span class="pre">.==</span> <span class="pre">B</span></tt>, and
similarly for the other boolean operators like <tt class="xref jl jl-obj docutils literal"><span class="pre">&lt;</span></tt>, <tt class="xref jl jl-obj docutils literal"><span class="pre">&gt;</span></tt> and
<tt class="xref jl jl-obj docutils literal"><span class="pre">=</span></tt>.</li>
<li>In Julia, the operators <tt class="xref jl jl-obj docutils literal"><span class="pre">&amp;</span></tt>, <tt class="xref jl jl-obj docutils literal"><span class="pre">|</span></tt>, and <tt class="xref jl jl-obj docutils literal"><span class="pre">$</span></tt> perform the bitwise
operations equivalent to <tt class="docutils literal"><span class="pre">and</span></tt>, <tt class="docutils literal"><span class="pre">or</span></tt>, and <tt class="docutils literal"><span class="pre">xor</span></tt> respectively in MATLAB,
and have precedence similar to Python&#8217;s bitwise operators (unlike C). They
can operate on scalars or element-wise across arrays and can be used to
combine logical arrays, but note the difference in order of operations:
parentheses may be required (e.g., to select elements of <tt class="docutils literal"><span class="pre">A</span></tt> equal to 1 or
2 use <tt class="docutils literal"><span class="pre">(A</span> <span class="pre">.==</span> <span class="pre">1)</span> <span class="pre">|</span> <span class="pre">(A</span> <span class="pre">.==</span> <span class="pre">2)</span></tt>).</li>
<li>In Julia, the elements of a collection can be passed as arguments to a
function using the splat operator <tt class="docutils literal"><span class="pre">...</span></tt>, as in <tt class="docutils literal"><span class="pre">xs=[1,2];</span> <span class="pre">f(xs...)</span></tt>.</li>
<li>Julia&#8217;s <tt class="xref jl jl-func docutils literal"><span class="pre">svd()</span></tt> returns singular values as a vector instead of as a dense
diagonal matrix.</li>
<li>In Julia, <tt class="docutils literal"><span class="pre">...</span></tt> is not used to continue lines of code. Instead, incomplete
expressions automatically continue onto the next line.</li>
<li>In both Julia and MATLAB, the variable <tt class="docutils literal"><span class="pre">ans</span></tt> is set to the value of the
last expression issued in an interactive session. In Julia, unlike MATLAB,
<tt class="docutils literal"><span class="pre">ans</span></tt> is not set when Julia code is run in non-interactive mode.</li>
<li>Julia&#8217;s <tt class="docutils literal"><span class="pre">type</span></tt>s do not support dynamically adding fields at runtime,
unlike MATLAB&#8217;s <tt class="docutils literal"><span class="pre">class</span></tt>es. Instead, use a <tt class="xref jl jl-obj docutils literal"><span class="pre">Dict</span></tt>.</li>
<li>In Julia each module has its own global scope/namespace, whereas in
Matlab there is just one global scope.</li>
</ul>
</div>
<div class="section" id="noteworthy-differences-from-r">
<h2>Noteworthy differences from R<a class="headerlink" href="#noteworthy-differences-from-r" title="Permalink to this headline">¶</a></h2>
<p>One of Julia&#8217;s goals is to provide an effective language for data analysis
and statistical programming. For users coming to Julia from R, these are some
noteworthy differences:</p>
<ul class="simple">
<li>Julia&#8217;s single quotes enclose characters, not strings.</li>
<li>Julia can create substrings by indexing into strings. In R, strings
must be converted into character vectors before creating substrings.</li>
<li>In Julia, like Python but unlike R, strings can be created with triple quotes
<tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span> <span class="pre">...</span> <span class="pre">&quot;&quot;&quot;</span></tt>. This syntax is convenient for constructing strings that
contain line breaks.</li>
<li>In Julia, varargs are specified using the splat operator <tt class="docutils literal"><span class="pre">...</span></tt>, which
always follows the name of a specific variable, unlike R, for which <tt class="docutils literal"><span class="pre">...</span></tt>
can occur in isolation.</li>
<li>In Julia, modulus, is <tt class="xref jl jl-obj docutils literal"><span class="pre">%</span></tt>, not <tt class="docutils literal"><span class="pre">%%</span></tt>.</li>
<li>In Julia, not all data structures support logical indexing. Furthermore,
logical indexing in Julia is supported only with vectors of length equal to
the object being indexed. For example:
- In R, <tt class="docutils literal"><span class="pre">c(1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4)[c(TRUE,</span> <span class="pre">FALSE)]</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">c(1,3)</span></tt>.
- In R, <tt class="docutils literal"><span class="pre">c(1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4)[c(TRUE,</span> <span class="pre">FALSE,</span> <span class="pre">TRUE,</span> <span class="pre">FALSE)]</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">c(1,3)</span></tt>.
- In Julia, <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4][[true,</span> <span class="pre">false]]</span></tt> throws a <tt class="xref jl jl-exc docutils literal"><span class="pre">BoundsError</span></tt>.
- In Julia, <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4][[true,</span> <span class="pre">false,</span> <span class="pre">true,</span> <span class="pre">false]]</span></tt> produces <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">3]</span></tt>.</li>
<li>Like many languages, Julia does not always allow operations on vectors of
different lengths, unlike R where the vectors only need to share a common
index range.  For example, <tt class="docutils literal"><span class="pre">c(1,2,3,4)</span> <span class="pre">+</span> <span class="pre">c(1,2)</span></tt> is valid R but the
equivalent <tt class="docutils literal"><span class="pre">[1:4]</span> <span class="pre">+</span> <span class="pre">[1:2]</span></tt> will throw an error in Julia.</li>
<li>Julia&#8217;s <tt class="xref jl jl-func docutils literal"><span class="pre">apply()</span></tt> takes the function first, then its arguments, unlike
<tt class="docutils literal"><span class="pre">lapply(&lt;structure&gt;,</span> <span class="pre">function,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></tt> in R.</li>
<li>Julia uses <tt class="docutils literal"><span class="pre">end</span></tt> to denote the end of conditional blocks, like <tt class="docutils literal"><span class="pre">if</span></tt>,
loop blocks, like <tt class="docutils literal"><span class="pre">while</span></tt>/<tt class="docutils literal"><span class="pre">for</span></tt>, and functions. In lieu of the one-line
<tt class="docutils literal"><span class="pre">if</span> <span class="pre">(</span> <span class="pre">cond</span> <span class="pre">)</span> <span class="pre">statement</span></tt>, Julia allows statements of the form
<tt class="docutils literal"><span class="pre">if</span> <span class="pre">cond;</span> <span class="pre">statement;</span> <span class="pre">end</span></tt>, <tt class="docutils literal"><span class="pre">cond</span> <span class="pre">&amp;&amp;</span> <span class="pre">statement</span></tt> and
<tt class="docutils literal"><span class="pre">!cond</span> <span class="pre">||</span> <span class="pre">statement</span></tt>. Assignment statements in the latter two syntaxes must
be explicitly wrapped in parentheses, e.g. <tt class="docutils literal"><span class="pre">cond</span> <span class="pre">&amp;&amp;</span> <span class="pre">(x</span> <span class="pre">=</span> <span class="pre">value)</span></tt>.</li>
<li>In Julia, <tt class="docutils literal"><span class="pre">&lt;-</span></tt>, <tt class="docutils literal"><span class="pre">&lt;&lt;-</span></tt> and <tt class="docutils literal"><span class="pre">-&gt;</span></tt> are not assignment operators.</li>
<li>Julia&#8217;s <tt class="docutils literal"><span class="pre">-&gt;</span></tt> creates an anonymous function, like Python.</li>
<li>Julia constructs vectors using brackets. Julia&#8217;s <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></tt> is the
equivalent of R&#8217;s <tt class="docutils literal"><span class="pre">c(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></tt>.</li>
<li>Julia&#8217;s <tt class="xref jl jl-obj docutils literal"><span class="pre">*</span></tt> operator can perform matrix multiplication, unlike in R.
If <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> are matrices, then <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></tt> denotes a matrix
multiplication in Julia, equivalent to R&#8217;s <tt class="docutils literal"><span class="pre">A</span> <span class="pre">%*%</span> <span class="pre">B</span></tt>. In R, this same
notation would perform an element-wise (Hadamard) product. To get the
element-wise multiplication operation, you need to write <tt class="docutils literal"><span class="pre">A</span> <span class="pre">.*</span> <span class="pre">B</span></tt> in Julia.</li>
<li>Julia performs matrix transposition using the <tt class="xref jl jl-obj docutils literal"><span class="pre">'</span></tt> operator and conjugated
transposition using the <tt class="xref jl jl-obj docutils literal"><span class="pre">'</span></tt> operator. Julia&#8217;s <tt class="docutils literal"><span class="pre">A.'</span></tt> is therefore
equivalent to R&#8217;s <tt class="docutils literal"><span class="pre">t(A)</span></tt>.</li>
<li>Julia does not require parentheses when writing <tt class="docutils literal"><span class="pre">if</span></tt> statements or
<tt class="docutils literal"><span class="pre">for</span></tt>/<tt class="docutils literal"><span class="pre">while</span></tt> loops: use <tt class="docutils literal"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></tt> instead of
<tt class="docutils literal"><span class="pre">for</span> <span class="pre">(i</span> <span class="pre">in</span> <span class="pre">c(1,</span> <span class="pre">2,</span> <span class="pre">3))</span></tt> and <tt class="docutils literal"><span class="pre">if</span> <span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></tt> instead of <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(i</span> <span class="pre">==</span> <span class="pre">1)</span></tt>.</li>
<li>Julia does not treat the numbers <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">1</span></tt> as Booleans.
You cannot write <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(1)</span></tt> in Julia, because <tt class="docutils literal"><span class="pre">if</span></tt> statements accept only
booleans. Instead, you can write <tt class="docutils literal"><span class="pre">if</span> <span class="pre">true</span></tt>, <tt class="docutils literal"><span class="pre">if</span> <span class="pre">Bool(1)</span></tt>, or <tt class="docutils literal"><span class="pre">if</span> <span class="pre">1==1</span></tt>.</li>
<li>Julia does not provide <tt class="docutils literal"><span class="pre">nrow</span></tt> and <tt class="docutils literal"><span class="pre">ncol</span></tt>. Instead, use <tt class="docutils literal"><span class="pre">size(M,</span> <span class="pre">1)</span></tt>
for <tt class="docutils literal"><span class="pre">nrow(M)</span></tt> and <tt class="docutils literal"><span class="pre">size(M,</span> <span class="pre">2)</span></tt> for <tt class="docutils literal"><span class="pre">ncol(M)</span></tt>.</li>
<li>Julia is careful to distinguish scalars, vectors and matrices.  In R,
<tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">c(1)</span></tt> are the same. In Julia, they can not be used
interchangeably. One potentially confusing result of this is that
<tt class="docutils literal"><span class="pre">x'</span> <span class="pre">*</span> <span class="pre">y</span></tt> for vectors <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> is a 1-element vector, not a scalar.
To get a scalar, use <tt class="xref jl jl-func docutils literal"><span class="pre">dot(x,</span> <span class="pre">y)</span></tt>.</li>
<li>Julia&#8217;s <tt class="xref jl jl-func docutils literal"><span class="pre">diag()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">diagm()</span></tt> are not like R&#8217;s.</li>
<li>Julia cannot assign to the results of function calls on the left hand side of
an assignment operation: you cannot write <tt class="docutils literal"><span class="pre">diag(M)</span> <span class="pre">=</span> <span class="pre">ones(n)</span></tt>.</li>
<li>Julia discourages populating the main namespace with functions. Most
statistical functionality for Julia is found in
<a class="reference external" href="http://pkg.julialang.org/">packages</a> under the <a class="reference external" href="https://github.com/JuliaStats">JuliaStats organization</a>. For example:<ul>
<li>Functions pertaining to probability distributions are provided by the
<a class="reference external" href="https://github.com/JuliaStats/Distributions.jl">Distributions package</a>.</li>
<li>The <a class="reference external" href="https://github.com/JuliaStats/DataFrames.jl">DataFrames package</a>
provides data frames.</li>
<li>Generalized linear models are provided by the <a class="reference external" href="https://github.com/JuliaStats/GLM.jl">GLM package</a>.</li>
</ul>
</li>
<li>Julia provides tuples and real hash tables, but not R-style lists. When
returning multiple items, you should typically use a tuple: instead of
<tt class="docutils literal"><span class="pre">list(a</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">2)</span></tt>, use <tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">2)</span></tt>.</li>
<li>Julia encourages users to write their own types, which are easier to use than
S3 or S4 objects in R. Julia&#8217;s multiple dispatch system means that
<tt class="docutils literal"><span class="pre">table(x::TypeA)</span></tt> and <tt class="docutils literal"><span class="pre">table(x::TypeB)</span></tt> act like R&#8217;s <tt class="docutils literal"><span class="pre">table.TypeA(x)</span></tt>
and <tt class="docutils literal"><span class="pre">table.TypeB(x)</span></tt>.</li>
<li>In Julia, values are passed and assigned by reference. If a function modifies
an array, the changes will be visible in the caller. This is very different
from R and allows new functions to operate on large data structures much more
efficiently.</li>
<li>In Julia, vectors and matrices are concatenated using <tt class="xref jl jl-func docutils literal"><span class="pre">hcat()</span></tt>,
<tt class="xref jl jl-func docutils literal"><span class="pre">vcat()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">hvcat()</span></tt>, not <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">rbind</span></tt> and <tt class="docutils literal"><span class="pre">cbind</span></tt> like in R.</li>
<li>In Julia, a range like <tt class="docutils literal"><span class="pre">a:b</span></tt> is not shorthand for a vector like in R,
but is a specialized <tt class="xref jl jl-obj docutils literal"><span class="pre">Range</span></tt> that is used for iteration without high
memory overhead. To convert a range into a vector, use <tt class="xref jl jl-func docutils literal"><span class="pre">collect(a:b)</span></tt>.</li>
<li>Julia&#8217;s <tt class="xref jl jl-func docutils literal"><span class="pre">max()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">min()</span></tt> are the equivalent of <tt class="docutils literal"><span class="pre">pmax</span></tt> and
<tt class="docutils literal"><span class="pre">pmin</span></tt> respectively in R, but both arguments need to have the same
dimensions.  While <tt class="xref jl jl-func docutils literal"><span class="pre">maximum()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">minimum()</span></tt> replace <tt class="docutils literal"><span class="pre">max</span></tt> and
<tt class="docutils literal"><span class="pre">min</span></tt> in R, there are important differences.</li>
<li>Julia&#8217;s <tt class="xref jl jl-func docutils literal"><span class="pre">sum()</span></tt>, <tt class="xref jl jl-func docutils literal"><span class="pre">prod()</span></tt>, <tt class="xref jl jl-func docutils literal"><span class="pre">maximum()</span></tt>, and <tt class="xref jl jl-func docutils literal"><span class="pre">minimum()</span></tt> are
different from their counterparts in R. They all accept one or two arguments.
The first argument is an iterable collection such as an array.  If there is a
second argument, then this argument indicates the dimensions, over which the
operation is carried out.  For instance, let <tt class="docutils literal"><span class="pre">A=[[1</span> <span class="pre">2],[3</span> <span class="pre">4]]</span></tt> in Julia and
<tt class="docutils literal"><span class="pre">B=rbind(c(1,2),c(3,4))</span></tt> be the same matrix in R.  Then <tt class="docutils literal"><span class="pre">sum(A)</span></tt> gives
the same result as <tt class="docutils literal"><span class="pre">sum(B)</span></tt>, but <tt class="docutils literal"><span class="pre">sum(A,</span> <span class="pre">1)</span></tt> is a row vector containing
the sum over each column and <tt class="docutils literal"><span class="pre">sum(A,</span> <span class="pre">2)</span></tt> is a column vector containing the
sum over each row.  This contrasts to the behavior of R, where
<tt class="docutils literal"><span class="pre">sum(B,1)=11</span></tt> and <tt class="docutils literal"><span class="pre">sum(B,2)=12</span></tt>.  If the second argument is a vector,
then it specifies all the dimensions over which the sum is performed, e.g.,
<tt class="docutils literal"><span class="pre">sum(A,[1,2])=10</span></tt>.  It should be noted that there is no error checking
regarding the second argument.</li>
<li>Julia has several functions that can mutate their arguments. For example,
it has both <tt class="xref jl jl-func docutils literal"><span class="pre">sort()</span></tt> and <tt class="xref jl jl-func docutils literal"><span class="pre">sort!()</span></tt>.</li>
<li>In R, performance requires vectorization. In Julia, almost the opposite is
true: the best performing code is often achieved by using devectorized loops.</li>
<li>Julia is eagerly evaluated and does not support R-style lazy evaluation. For
most users, this means that there are very few unquoted expressions or column
names.</li>
<li>Julia does not support the <tt class="docutils literal"><span class="pre">NULL</span></tt> type.</li>
<li>Julia lacks the equivalent of R&#8217;s <tt class="docutils literal"><span class="pre">assign</span></tt> or <tt class="docutils literal"><span class="pre">get</span></tt>.</li>
<li>In Julia, <tt class="docutils literal"><span class="pre">return</span></tt> does not require parentheses.</li>
</ul>
</div>
<div class="section" id="noteworthy-differences-from-python">
<h2>Noteworthy differences from Python<a class="headerlink" href="#noteworthy-differences-from-python" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>In Julia, a vector of vectors can automatically concatenate into a
one-dimensional vector <em>if</em> no explicit element type is specified. For example:<ul>
<li>In Julia, <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">[2,</span> <span class="pre">3]]</span></tt> concatenates into <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></tt>, like in R.</li>
<li>In Julia, <tt class="docutils literal"><span class="pre">Int[1,</span> <span class="pre">Int[2,</span> <span class="pre">3]]</span></tt> will <em>not</em> concatenate, but instead throw an error.</li>
<li>In Julia, <tt class="docutils literal"><span class="pre">Any[1,</span> <span class="pre">[2,3]]</span></tt> will <em>not</em> concatenate.</li>
<li>In Julia, <tt class="docutils literal"><span class="pre">Vector{Int}[[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]]</span></tt> will <em>not</em> concatenate, but
produces an object similar to Python&#8217;s list of lists. This object is
<em>different</em> from a two-dimensional <tt class="xref jl jl-obj docutils literal"><span class="pre">Array</span></tt> of <tt class="xref jl jl-obj docutils literal"><span class="pre">Int</span></tt>s.</li>
</ul>
</li>
<li>Julia requires <tt class="docutils literal"><span class="pre">end</span></tt> to end a block. Unlike Python, Julia has no <tt class="docutils literal"><span class="pre">pass</span></tt>
keyword.</li>
<li>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</li>
<li>Julia&#8217;s slice indexing includes the last element, unlike in Python.
<tt class="docutils literal"><span class="pre">a[2:3]</span></tt> in Julia is <tt class="docutils literal"><span class="pre">a[1:3]</span></tt> in Python.</li>
<li>Julia does not support negative indexes. In particular, the last element of a
list or array is indexed with <tt class="xref jl jl-obj docutils literal"><span class="pre">end</span></tt> in Julia, not <tt class="docutils literal"><span class="pre">-1</span></tt> as in Python.</li>
<li>Julia&#8217;s list comprehensions do not support the optional <tt class="docutils literal"><span class="pre">if</span></tt> clause that
Python has.</li>
<li>Julia&#8217;s <tt class="docutils literal"><span class="pre">for</span></tt>, <tt class="docutils literal"><span class="pre">if</span></tt>, <tt class="docutils literal"><span class="pre">while</span></tt>, etc. blocks are terminated by the
<tt class="docutils literal"><span class="pre">end</span></tt> keyword. Indentation level is not significant as it is in Python.</li>
<li>Julia has no line continuation syntax: if, at the end of a line, the input so
far is a complete expression, it is considered done; otherwise the input
continues. One way to force an expression to continue is to wrap it in
parentheses.</li>
<li>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row
major (C-ordered) by default. To get optimal performance when looping over
arrays, the order of the loops should be reversed in Julia relative to NumPy
(see relevant section of <a class="reference internal" href="performance-tips.html#man-performance-tips"><em>Performance Tips</em></a>).</li>
<li>Julia&#8217;s updating operators (e.g. <tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, ...) are <em>not in-place</em>
whereas NumPy&#8217;s are. This means <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">ones(4);</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">A;</span> <span class="pre">B</span> <span class="pre">+=</span> <span class="pre">3</span></tt> doesn&#8217;t change
values in <tt class="docutils literal"><span class="pre">A</span></tt>, it rather rebinds the name <tt class="docutils literal"><span class="pre">B</span></tt> to the result of the right-
hand side <tt class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">+</span> <span class="pre">3</span></tt>, which is a new array. Use <tt class="docutils literal"><span class="pre">B[:]</span> <span class="pre">+=</span> <span class="pre">3</span></tt>, explicit loops,
or <tt class="docutils literal"><span class="pre">InplaceOps.jl</span></tt>.</li>
<li>Julia evaluates default values of function arguments every time the method is
invoked, unlike in Python where the default values are evaluated only once
when the function is defined. For example, the function <tt class="docutils literal"><span class="pre">f(x=rand())</span> <span class="pre">=</span> <span class="pre">x</span></tt>
returns a new random number every time it is invoked without argument. On the
other hand, the function <tt class="docutils literal"><span class="pre">g(x=[1,2])</span> <span class="pre">=</span> <span class="pre">push!(x,3)</span></tt> returns <tt class="docutils literal"><span class="pre">[1,2,3]</span></tt> every
time it is called as <tt class="docutils literal"><span class="pre">g()</span></tt>.</li>
</ul>
</div>
<div class="section" id="noteworthy-differences-from-c-c">
<h2>Noteworthy differences from C/C++<a class="headerlink" href="#noteworthy-differences-from-c-c" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Julia arrays are indexed with square brackets, and can have more than one
dimension <tt class="docutils literal"><span class="pre">A[i,j]</span></tt>.
This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++.
See the Julia documentation for the syntax for array construction (it has changed between versions).</li>
<li>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</li>
<li>Julia arrays are assigned by reference. After <tt class="docutils literal"><span class="pre">A=B</span></tt>, changing elements of
<tt class="docutils literal"><span class="pre">B</span></tt> will modify <tt class="docutils literal"><span class="pre">A</span></tt> as well. Updating operators like <tt class="docutils literal"><span class="pre">+=</span></tt> do not operate
in-place, they are equivalent to <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></tt> which rebinds the left-hand
side to the result of the right-hand side expression.</li>
<li>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row
major ordered by default. To get optimal performance when looping over
arrays, the order of the loops should be reversed in Julia relative to C/C++
(see relevant section of <a class="reference internal" href="performance-tips.html#man-performance-tips"><em>Performance Tips</em></a>).</li>
<li>Julia values are passed and assigned by reference. If a function modifies an
array, the changes will be visible in the caller.</li>
<li>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing
whitespace from a Julia program.</li>
<li>In Julia, literal numbers without a decimal point (such as <tt class="docutils literal"><span class="pre">42</span></tt>) create signed
integers, of type <tt class="docutils literal"><span class="pre">Int</span></tt>, but literals too large to fit in the machine word size
will automatically be promoted to a larger size type, such as <tt class="docutils literal"><span class="pre">Int64</span></tt> (if <tt class="docutils literal"><span class="pre">Int</span></tt> is <tt class="docutils literal"><span class="pre">Int32</span></tt>),
<tt class="docutils literal"><span class="pre">Int128</span></tt>, or the arbitrarily large <tt class="docutils literal"><span class="pre">BigInt</span></tt> type.
There are no numeric literal suffixes, such as <tt class="docutils literal"><span class="pre">L</span></tt>, <tt class="docutils literal"><span class="pre">LL</span></tt>, <tt class="docutils literal"><span class="pre">U</span></tt>, <tt class="docutils literal"><span class="pre">UL</span></tt>, <tt class="docutils literal"><span class="pre">ULL</span></tt> to indicate unsigned
and/or signed vs. unsigned.
Decimal literals are always signed, and hexadecimal literals (which start with <tt class="docutils literal"><span class="pre">0x</span></tt> like C/C++),
are unsigned.
Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia,
have a type based on the <em>length</em> of the literal, including leading 0s.  For example,
<tt class="docutils literal"><span class="pre">0x0</span></tt> and <tt class="docutils literal"><span class="pre">0x00</span></tt> have type UInt8, <tt class="docutils literal"><span class="pre">0x000</span></tt> and <tt class="docutils literal"><span class="pre">0x0000</span></tt> have type <tt class="docutils literal"><span class="pre">UInt16</span></tt>, then
literals with 5 to 8 hex digits have type <tt class="docutils literal"><span class="pre">UInt32</span></tt>, 9 to 16 hex digits type <tt class="docutils literal"><span class="pre">UInt64</span></tt> and 17 to 32 hex digits type <tt class="docutils literal"><span class="pre">UInt128</span></tt>.
This needs to be taken into account when defining
hexadecimal masks, for example <tt class="docutils literal"><span class="pre">~0xf</span> <span class="pre">==</span> <span class="pre">0xf0</span></tt> is very different from <tt class="docutils literal"><span class="pre">~0x000f</span> <span class="pre">==</span> <span class="pre">0xfff0</span></tt>.
64 bit <tt class="docutils literal"><span class="pre">Float64</span></tt> and 32 bit <tt class="docutils literal"><span class="pre">Float32</span></tt> bit literals are expressed as <tt class="docutils literal"><span class="pre">1.0</span></tt> and <tt class="docutils literal"><span class="pre">1.0f0</span></tt> respectively.
Floating point literals are rounded (and not promoted to the <tt class="docutils literal"><span class="pre">BigFloat</span></tt> type) if they can not be exactly
represented.  Floating point literals are closer in behavior to C/C++.
Octal (prefixed with <tt class="docutils literal"><span class="pre">0o</span></tt>) and binary (prefixed with <tt class="docutils literal"><span class="pre">0b</span></tt>) literals are also treated as unsigned.</li>
<li>String literals can be delimited with either <tt class="docutils literal"><span class="pre">&quot;</span></tt>  or <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> delimited literals can contain <tt class="docutils literal"><span class="pre">&quot;</span></tt>
characters without quoting it like <tt class="docutils literal"><span class="pre">&quot;\&quot;&quot;</span></tt>
String literals can have values of other variables or expressions interpolated into them,
indicated by <tt class="docutils literal"><span class="pre">$variablename</span></tt> or <tt class="docutils literal"><span class="pre">$(expression)</span></tt>, which evaluates the variable name or the expression in the context of the function.</li>
<li><tt class="docutils literal"><span class="pre">//</span></tt> indicates a <tt class="docutils literal"><span class="pre">Rational</span></tt> number, and not a single-line comment (which is <tt class="docutils literal"><span class="pre">#</span></tt> in Julia)</li>
<li><tt class="docutils literal"><span class="pre">#=</span></tt> indicates the start of a multiline comment, and <tt class="docutils literal"><span class="pre">=#</span></tt> ends it.</li>
<li>Functions in Julia return values from their last expression(s) or the <tt class="docutils literal"><span class="pre">return</span></tt>
keyword.  Multiple values can be returned from functions and assigned as tuples, e.g.
<tt class="docutils literal"><span class="pre">(a,</span> <span class="pre">b)</span> <span class="pre">=</span> <span class="pre">myfunction()</span></tt> or <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">myfunction()</span></tt>, instead of having to pass pointers
to values as one would have to do in C/C++ (i.e. <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">myfunction(&amp;b)</span></tt>.</li>
<li>Julia does not require the use of semicolons to end statements. The results of
expressions are not automatically printed (except at the interactive prompt, i.e. the REPL),
and lines of code do not need to end with semicolons. <tt class="xref jl jl-func docutils literal"><span class="pre">println()</span></tt> or
<tt class="xref jl jl-func docutils literal"><span class="pre">&#64;printf()</span></tt> can be used to print specific output.
In the REPL, <tt class="docutils literal"><span class="pre">;</span></tt> can be used to suppress output.
<tt class="docutils literal"><span class="pre">;</span></tt> also has a different meaning within <tt class="docutils literal"><span class="pre">[</span> <span class="pre">]</span></tt>, something to watch out for.
<tt class="docutils literal"><span class="pre">;</span></tt> can be used to separate expressions on a single line, but are not strictly necessary in many cases,
and are more an aid to readability.</li>
<li>In Julia, the operator <tt class="xref jl jl-obj docutils literal"><span class="pre">$</span></tt> performs the bitwise XOR operation, i.e. <tt class="xref jl jl-obj docutils literal"><span class="pre">^</span></tt>
in C/C++.  Also, the bitwise operators do not have the same precedence as C/++,
so parenthesis may be required.</li>
<li>Julia&#8217;s <tt class="xref jl jl-obj docutils literal"><span class="pre">^</span></tt> is exponentiation (pow), not bitwise XOR as in C/C++ (use <tt class="xref jl jl-obj docutils literal"><span class="pre">$</span></tt> in Julia)</li>
<li>Julia has two right-shift operators, <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt>.  <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> performs an arithmetic shift,
<tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> always performs a logical shift, unlike C/C++,
where the meaning of <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> depends on the type of the value being shifted.</li>
<li>Julia&#8217;s <tt class="docutils literal"><span class="pre">-&gt;</span></tt> creates an anonymous function, it does not access a member via a pointer.</li>
<li>Julia does not require parentheses when writing <tt class="docutils literal"><span class="pre">if</span></tt> statements or
<tt class="docutils literal"><span class="pre">for</span></tt>/<tt class="docutils literal"><span class="pre">while</span></tt> loops: use <tt class="docutils literal"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></tt> instead of
<tt class="docutils literal"><span class="pre">for</span> <span class="pre">(int</span> <span class="pre">i=1;</span> <span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">3;</span> <span class="pre">i++)</span></tt> and <tt class="docutils literal"><span class="pre">if</span> <span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></tt> instead of <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(i</span> <span class="pre">==</span> <span class="pre">1)</span></tt>.</li>
<li>Julia does not treat the numbers <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">1</span></tt> as Booleans.
You cannot write <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(1)</span></tt> in Julia, because <tt class="docutils literal"><span class="pre">if</span></tt> statements accept only
booleans. Instead, you can write <tt class="docutils literal"><span class="pre">if</span> <span class="pre">true</span></tt>, <tt class="docutils literal"><span class="pre">if</span> <span class="pre">Bool(1)</span></tt>, or <tt class="docutils literal"><span class="pre">if</span> <span class="pre">1==1</span></tt>.</li>
<li>Julia uses <tt class="docutils literal"><span class="pre">end</span></tt> to denote the end of conditional blocks, like <tt class="docutils literal"><span class="pre">if</span></tt>,
loop blocks, like <tt class="docutils literal"><span class="pre">while</span></tt>/<tt class="docutils literal"><span class="pre">for</span></tt>, and functions. In lieu of the one-line
<tt class="docutils literal"><span class="pre">if</span> <span class="pre">(</span> <span class="pre">cond</span> <span class="pre">)</span> <span class="pre">statement</span></tt>, Julia allows statements of the form
<tt class="docutils literal"><span class="pre">if</span> <span class="pre">cond;</span> <span class="pre">statement;</span> <span class="pre">end</span></tt>, <tt class="docutils literal"><span class="pre">cond</span> <span class="pre">&amp;&amp;</span> <span class="pre">statement</span></tt> and
<tt class="docutils literal"><span class="pre">!cond</span> <span class="pre">||</span> <span class="pre">statement</span></tt>. Assignment statements in the latter two syntaxes must
be explicitly wrapped in parentheses, e.g. <tt class="docutils literal"><span class="pre">cond</span> <span class="pre">&amp;&amp;</span> <span class="pre">(x</span> <span class="pre">=</span> <span class="pre">value)</span></tt>, because
of the operator precedence.</li>
<li>Julia has no line continuation syntax: if, at the end of a line, the input so
far is a complete expression, it is considered done; otherwise the input
continues. One way to force an expression to continue is to wrap it in
parentheses.</li>
<li>Julia macros operate on parsed expressions, rather than the text of the program,
which allows them to perform sophisticated transformations of Julia code. Macro
names start with the <tt class="docutils literal"><span class="pre">&#64;</span></tt> character, and have both a function-like syntax,
<tt class="docutils literal"><span class="pre">&#64;mymacro(arg1,</span> <span class="pre">arg2,</span> <span class="pre">arg3)</span></tt>, and a statement-like syntax,
<tt class="docutils literal"><span class="pre">&#64;mymacro</span> <span class="pre">arg1</span> <span class="pre">arg2</span> <span class="pre">arg3</span></tt>. The forms are interchangable; the function-like form
is particularly useful if the macro appears within another expression, and is often clearest.
The statement-like form is often used to annotate blocks, as in the parallel <tt class="docutils literal"><span class="pre">for</span></tt>
construct: <tt class="docutils literal"><span class="pre">&#64;parallel</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">1:n;</span> <span class="pre">#=</span> <span class="pre">body</span> <span class="pre">=#;</span> <span class="pre">end</span></tt>. Where the end of the macro
construct may be unclear, use the function-like form.</li>
<li>Julia now has an enumeration type, expressed using the macro <tt class="docutils literal"><span class="pre">&#64;enum(name,</span> <span class="pre">value1,</span> <span class="pre">value2,</span> <span class="pre">...)</span></tt>
For example: <tt class="docutils literal"><span class="pre">&#64;enum(Fruit,</span> <span class="pre">Banana=1,</span> <span class="pre">Apple,</span> <span class="pre">Pear)</span></tt></li>
<li>By convention, functions that modify their arguments have a <tt class="docutils literal"><span class="pre">!</span></tt> at the end of the name,
for example <tt class="docutils literal"><span class="pre">push!</span></tt>.</li>
<li>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual,
in order to have dynamic dispatch.
On the other hand, in Julia every method is &#8220;virtual&#8221; (although it&#8217;s more general than that
since methods are dispatched on every argument type, not only <tt class="docutils literal"><span class="pre">this</span></tt>, using the most-specific-declaration rule).</li>
</ul>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="unicode-input.html" class="btn btn-neutral float-right" title="Unicode Input" accesskey="n"> 다음 <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="faq.html" class="btn btn-neutral" title="Frequently Asked Questions" accesskey="p"><span class="fa fa-arrow-circle-left"></span> 이전 </a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on Apr 07, 2016.
    </p>
  </div>

</footer>


<div
  class="fb-like"
  data-share="true"
  data-width="450"
  data-show-faces="true">
</div>

<script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '685509058259607',
      xfbml      : true,
      version    : 'v2.3'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "https://connect.facebook.net/ko_KR/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-width="100%" data-version="v2.3"></div>

        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'X.Y.Z-unknown',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   


<script type="text/javascript" src="../_static/jquery.word-break-keep-all.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('p').wordBreakKeepAll();
});
</script>

<script type="text/javascript" src="../_static/blame.js"></script>

</body>
</html>